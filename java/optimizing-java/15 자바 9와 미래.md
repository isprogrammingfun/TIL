## 자바 9와 미래

자바 9는 “모듈과 그 나머지”이다. 자바 8이 람다와 그 결과물에 중점을 두었다면 자바 9는 거의 모듈에 관한 버전이다. 

모듈은 소프트웨어를 개발/배포하는 완전히 새로운 방식이라서 하나씩 단계적으로 도입하기가 어렵다. 모듈은 아키텍처가 잘 갖추어진 애플리케이션을 구축하는 최신 방법론이지만, 개발 프로젝트에 모듈을 적용해서 장기적인 효과를 보려면 다소 시간이 걸릴 수 있다. 모듈은 실제 성능 측면에서 크게 중요한 비중을 차지하지는 않는다. 

### 자바 9에서 소소하게 개선된 성능

다음은 성능 측면에서 자바 9부터 개선된 사항이다. 

- 코드 캐시 세그먼트화
- 콤팩트 스트링
- 새로운 스트링 연결
- C2 컴파일러 개선
- G1 새 버전

**코드 캐시 세그먼트화**

자바 9부터 코드 캐시 성능을 개선하고자 다음 항목별로 영역을 분리했다. 

- 인터프리터 등의 논메서드 코드
- 프로파일드 코드
- 논프로파일드 코드

이 덕분에 스위퍼 가동 시간이 짧아지고 풀 최적화 코드에 대한 코드 지역성이 향상된다. 다른 영역은 공간이 남는데 특정 영역이 꽉 찰 수 있다는 단점은 있다. 

**콤팩트 스트링**

자바에서 스트링 콘텐츠는 항상 char[] 타입으로 저장된다. char는 16비트 타입이라서 ASCII 스트링을 저장하면 실제로 필요한 공간의 2배 정도를 더 차지한다. 자바 플랫폼에서 유니코드를 단순하게 처리하려면 어쩔 수 없는 오버헤드로 취급했다. 

자바 9 이후 콤팩트 스트링 덕에 스트링 단위로 최적화할 수 있다. 이제 Latin-1 캐릭터로 표기 가능한 스트링은 byte 배열로 나타낼 수 있으므로 기존 char 배열로 나타낼 때 0으로 채워졌던 바이트 개수만큼 절약할 수 있다. 

자바 9부터 String 클래스의 소스 코드에 value 필드 타입이 char[]가 아니라 byte[]로 변경되었다.

 Latin-1, 또는 ASCII 스트링 데이터가 가득한 대용량 힙을 지닌 애플리케션에서는 상당한 성능 효과를 기대할 수 있다. 이런 애플리케이션은 콤팩트 스트링 하나만으로도 자바 9로 런타임을 업그레이드할 명분이 확실하다. 

**새로운 스트링 연결**

문자열을 붙이는 코드에서 자바 5 이래로 StringBuilder를 많이 사용해왔다. 그러나 이렇게 사용하면 바이트코드가 너무 많이 생성된다. 

하지만 자바 9부터 invokedynamic을 사용하면 생성되는 바이트코드를 줄일 수 있다. invokedynamic에선 `StringConcatFactory.makeConcatWithConstants()` 라는 팩토리 메서드로 스트링 연결 레시피를 제공한다. 

이 기법을 응용하면 새로운 커스텀 메서드용 바이트코드 작성 등 다양한 전략을 구사할 수 있다.

**C2 컴파일러 개선**

C2 컴파일러는 많이 성숙했고 앞으로 현재 구조에서 눈에 띄는 개선을 없을 것이다. 하지만 현대 CPU에 선보인 SIMD(single instruction multiple data) 확장 기능을 응용하면 성능 개선을 기대할 수 있다.

다른 프로그래밍 환경에 비해 자바/JVM은 플랫폼 특성 덕분에 SIMD를 더 효과적으로 활용하기 좋은 조건을 가지고 있다. 

- 바이트코드는 플랫폼과 무관하다.
- JVM은 시동 시 CPU를 탐색하므로 자신이 어떤 능력을 지닌 하드웨어에서 실행되고 있는지 런타임에 파악 가능하다.
- JIT 컴파일은 코드를 동적 생성하기 때문에 사용 가능한 모든 명령을 호스트에서 사용할 수 있다.

이러한 개선은 VM 인트린직으로 구현할 수 있다.

핫스팟은 이미 다음과 같은 x86 SIMD 명령어를 지원

- 자바 코드의 자동 백터화
- 순차 코드에서 SIMD 코드를 얻기 위해 C2에서 슈퍼워드 최적화
- 배열 복사/적재/비교 등의 JVM SIMD 인트린직

자바 9 버전은 SIMD의 장점 및 그와 연관된 프로세서 특성을 잘 활용하고자 기존 인트린직을 개선하거나 새로운 인트린직을 탑재했다. 릴리즈 노트에는 개선된 인트린직을 추가해 다음과 같은 이슈를 조치했고 적혀있다. 

- 마스킹된 백터 포스트 루프
- 슈퍼워드 루프 펼치기 분석
- 멀티비저닝으로 범위 체크 제거
- 배정도 제곱근 백터화 지원
- 병렬 스트림의 백터화 개선
- 슈퍼워드를 개선하여 인텔 AVX CPU상에서 백터 조건부 이동 지원

일반적으로 인트린직은 범용 기술이 아닌 특정 해결책이라 봐야 한다. 가볍고, 강력하고 유연하지만 여러 아키텍처를 고루 지원해야 하므로 개발/유지보수 비용이 많이 들 가능성이 크다. 

**G1 새 버전**

G1은 중단 시간을 쉽게 튜닝하고 더 효과적으로 제어하는 특성을 지닌, 여러 가지 문제를 한꺼번에 해결하고자 설계된 수집기이다.

자바 9부터 G1이 디폴트 가비지 수집기가 되었다. 이 때문에 어떤 수집기를 명시하지 않은 채 자바 8에서 9로 플랫폼을 이전하면 수집기 알고리즘이 달라져서 애플리케이션에 영향을 줄 수 있다. 자바 9 G1과 자바 8 G1은 버전도 다르다. 따하서 자바 9로 이전한 애플리케이션은 별다른 문제는 없는지 성능 테스트를 꼼꼼히 해야 한다. 

### 자바 10과 그 이후 버전

**자바 10**

JVM 특성 및 개선 사항은 자바 개선 프로세스를 통해 관리하며, JDK 개선 제안서 마다 관리 번호를 하나씩 매긴다. 

다음은 자바 10 주요 특성의 일부이다.

- 286: 지역 변수 타입 추론
- 296: JDK 포레스트를 단일 리파지터리로 통합
- 304: 가비지 수집기 인터페이스
    - 서로 다른 가비지 수집기의 코드를 더 분리해서 동일한 JDK 빌드에서 가비지 수집기 인터페이스를 깔끔하게 하자는 아이디어
- 307: G1에서 풀 병렬 GC 구현
    - G1 가비지 수집기의 풀 GC로 돌아가더라도 성능이 떨어질 수 있는 고질적인 문제점을 해결
    - 자바 9 G1에 구현된 풀 GC는 싱글 스레드인 마크-스위프-컴팩트 알고리즘 사용
    - JEP 307에선 이 알고리즘을 병렬화해서 G1에서 풀 GC가 발생할 경우, 같은 개수의 스레드를 그대로 동시 수집에 사용하자는 발상
- 310: 애플리케이션 클래스 데이터 공유
    - 자바 5에서 도입된 클래스 데이터 공유 특성을 확장
    - JVM이 일습의 클래스를 기록해 공유 아카이브 파일 하나로 처리한 뒤에 메모리에 매핑하면 다음에 실행할 때 시작 시간 절약 가능
    - 여러 JVM이 공유할 수 있어서 같은 호스트에서  멀티 JVM을 실행하는 환경은 전체 메모리 사용량이 줄어든다.
    - 애플리케이션, 커스텀 클래스로더도 아카이브 파일을 활용할 수 있게 확장하자는 취지
- 312: 스레드 로컬 핸드쉐이크
    - 전역 VM 세이브포인트를 수행하지 않고 애플리케이션 스레드에 콜백을 실행할 수 있게 해서 VM 성능을 개선하는 토대를 제공
    - JVM이 스레드 전체가 아니라, 개별 스레드 단위로 멈출 수 있게 하자
    - 이 기능이 구현되면 다음과 같은 일도 가능하다
        - 스택 트레이스 샘플을 획득하는 영향도를 낮출 수 있다.
        - 신호 의존도가 줄어들어 스택 트레이스 샘플링을 더 잘할 수 있다.
        - 바이어스를 취소할 때 개별 스레드만 중단시킬 수 있어서 바이어스 락킹 작업이 향상된다.
        - JVM에서 일부 메모리 베리어를 제거한다.

### 자바 9 Unsafe 그 너머

Unsafe는 자바 표준 API는 아니지만 자바 8부터 사실상 표준이 되었다. 라이브러리 개발자 입장에서 Unsafe에는 다양한 안전 기능이 버무러져 있다.

CAS 하드웨어에 엑세스하는 메서드는 완전 안전하지만 비표준이다. 다른 메서드는 전혀 안전하지 않은 데다 포인터 연산과 동등한 코드가 들어 있다. 

그러나 이처럼 ‘전혀 안전하지 않은’ 기능을 다른 방법으로는 얻을 수 없기 때문에 오라클은 이런 기능을 ‘핵심 내부 API’라 부른다.

문제는 `sun.misc.Unsafe` 와 관련 클래스에 구현된 기능을 대체할 기술이 없다면 주요 프레임워크와 라이브러리는 더 이상 작동하지 않을 것이다.

자바 9에는 `—illegal-access` 라는 스위치가 추가돼서 이 API에 대한 런타임 엑세스를 조정할 수 있다. 핵심 내부 API는 차기 버전에서 뾰족한 대한을 만들어 교체하려고 했지만, 자바 9 출시 전에는 이 작업을 미처 다 끝내지 못했다.

**자바 9의 VarHandle**

메서드 핸들은 메서드 레퍼런스를 직접 조작할 수 있지만, getter/setter 엑세스만 지원하고 필드까지 100% 완벽하게 지원하는건 아니다.

자바 9부터 메서드 핸들은 가변 핸들까지 포괄하도록 확장되었다. 이 의도는 Unsafe에 있는 API 일부를 안전하게 대체하여 간극을 메우고 JDK 9에서 JMM 업데이트 중 하나로 가능해진 메모리 순서 모드로 저수준 액세스를 하는 것이다. 

### 발할라 프로젝트와 값 타입

발할라 프로젝트의 목표는 다음과 같다

- JVM 메모리 레이아웃을 최신 하드웨어 비용 모델에 맞게 조정한다.
- 제네릭스가 기본형, 값, void까지 포함하도록 모든 타입에 추상화한다.
- 기존 라이브러리, 특히 JDK가 이러한 특성을 최대한 활용하도록 호환성을 유지하며 진화하도록 한다.

JVM에서 값 타입의 사용 가능성을 모색하는 것이 이 프로젝트에서 가장 역점을 둔 연구 분야이다.

9 버전 이전까지 자바에서 값 타입은 기본형과 참조형 두 가지뿐이다. 개발자가 저수준 메모리 레리아웃을 직접 손대지 않게 하려고 자바 환경을 그렇게 만든 것이다.  자바는 구조체가 따로 없고 모든 복합 자료형은 오직 레퍼런스를 통해서만 엑세스할 수 있다. 

자바 플랫폼은 20년 넘게 이러한 메모리 레이아웃 패턴을 토대로 삼았다. 단순하다는 게 장점이지만, 객체 배열을 처리하려면 간접화는 불가피하며 캐시 미스도 수반되므로 성능 감소는 감수해야 한다. 

성능을 중시하는 프로그래머들은 메모리를 더 효과적으로 배치할 수 있는 타입을 직접 정의하고 싶어 했다. 이게 가능하면 복합 데이터 원소마다 풀 객체 헤더가 필요한 오버헤드도 줄일 수 있기 때문이다. 

이 개념을 JVM에서 구현할 수 있으면 공간 좌표 같은 단순 타입 객체를 메모리처럼 배치할 수 있어 훨씬 효율적일 것이다. 이뿐만 아니라, 내장 기본형과 비슷하게 동작하는 사용자 정의 타입 등 다른 가능성도 모색할 수 있다. 

하지만 자바 5부터 제네릭이 등장하면서 난관이 생겼다. 자바는 최상위 타입이 따로 없기 때문에 Object와 int 모두의 슈퍼타입은 존재하지 않는다. 즉, 자바의 타입은 하나의 조상에서 분화된 체계가 아니다. 

이런 이유로, 자바 제네릭스는 참조형에만 적용된다. 가령 List<int> 처럼 일관된 의미를 부여할 방법이 마땅치 않다. 자바는 타입 소거를 이용해 참조형에 하위 호환성이 보장되는 제네릭 타입을 구현했지만, 최상위 타입의 부재와 그로 인한 기본형 컬렉션의 부재라는 문제를 해결할 수 없다. 

따라서 값 타입은 반드시 제네릭스를 개선한 형태에서 타입 매개변수 값으로 유효하다는 전제하에 설계해야 한다.

### 그랄과 트러플

핫스팟 내장 C2 컴파일러는 큰 성공을 거두었으나, 최근 수년간 수확 체감 현상이 두드러졌고 이렇다 할 컴파일러의 개선 사항도 반영된 적이 없다. 사실상 C2는 거의 수명이 다 됐고 교체할 시기가 됐다. 

→ C2 컴파일러는 C++로 작성되어 있어서 개발자가 수동으로 직접 메모리를 관리하는 안전하지 않은 언어라서 언제라도 C2 코드가 VM을 멎게 할 위험성이 있다. 

새로운 대체품을 찾는 연구 프로젝트는 현재 그랄과 트러플 위주로 진행되고 있다. 그랄은 JVM 용 JIT 컴파일러를 자바 언어로 개발하고, 트러플은 JVM에 기반한 언어 전용 인터프리터를 개발하는 프레임워크로, 입력 언어에 대한 고성능 JIT 컴파일러를 인터프리터에서 자동 생성하는 라이브러리이다. 

그랄 프로젝트의 사상은, JIT 컴파일러는 JVM 바이트코드를 받아 기계어를 생성하기만 하면 된다는 것이다. 이렇게 자바를 자바로 접근하는 방식은 단순함, 메모리 보안 등 여러 면에서 좋다. 그리고 IDE, 디버거 등의 표준 자바 툴 세트를 이용할 수 있는 장점이 있다. 또한 커스텀 인트린직 또는 최적화 패스 개발 등 자신 애플리케이션에 맞게 그랄의 일부를 수정할 수 있는 유연성도 장점이다.

### 바이트코드의 향후 발전 방향

VM에서 가장 큰 변화는 `invokedynamic` 명령어의 등장이다. 이는 JVM 바이트코드 작성 방법을 다시 생각하게 만든 도화선 역할을 했다. 앞으로는 이 옵코드에 적용된 기술을 활용해 플랫폼을 더 유연하게 만들려는 시도가 많아질 것이다. 

궁극적 목표는 `invokedynamic`을 호출하더라도 `invokevirtual`처럼 JIT 컴파일하기 좋고 성능도 좋게 나오도록 하는 것이다.

### 동시성의 항후 발전 방향

당초 자바 스레딩 모델은 모든 스레드를 개발자가 관리하고 가변 상태는 락으로 보호해야 한다는 설계 사상에 근거했다. 그래서 코드 어느 한 부분이라도 락킹을 정확히 구현하지 않으면 객체 상태가 무너질 수 있는 구조였다. 

이러한 초기 설계와는 반대로 나중에 등장한 자바 버전은 좀 더 고수준의, 개발자 손이 덜 가고 일반적으로 더 안전하게, 사실상 런타임이 동시성을 관리하는 방향으로 진화하였다.

룸 프로젝트도 그러한 노력의 일환이다. 룸 프로젝트는 지금까지 동시성을 JVM 상에서 지원했던 것과 달리, 더 저수준에서 지원하는 방안을 모색했다. 코어 자바 스레드의 근본적인 문제점은 모든 스레드가 스택을 달고 다닌다는 것이다. 비용도 많이 들고 무한히 확장할 수도 없다. 예를 들어 스레드가 10000개가 있으면 수 기가바이트에 달하는 메모리를 써야 한다.

OS가 직접 스케줄링 할 수 없는 실행 유닛은 오버헤드가 낫고 이는 고루틴, 파이버, 연속체 같은 저수준 협력 체제와 조화를 이룬다. 이런 추상화 장치들은 반드시 선점형이 아니라 협동형 모드로 동작해야 한다. OS가 바라볼 수 있는 범위 이하에서 작동하며 스케줄 가능한 항목을 자체 구성하지 않기 때문이다. 

이렇게 접근하려면 두 가지 기본 컴포넌트인, 피호출 코드의 표현형과 스케줄러 컴포넌트가 필요하다. 역설적으로 JVM은 7버전부터 이런 추상화 장치를 스케줄링하는 컴포넌트를 지니고 있었다. 

자바 7부터 등장한 포크/조인 API는 실행 가능한 태스크의 재귀 분해, 작업 훔쳐오기, 두 가지 개념에 기초한다. `ForkJoinPool` 실행자가 바로 이 두 개념의 핵심으로, 작업 훔쳐오기 알고리즘 구현을 담당한다. 재귀 분해가 모든 태스크에 유용한 건 아니지만, 작업 훔쳐오기 알고리즘이 가미된 실행자 스레드 풀은 다양한 상황에 적용할 수 있다.