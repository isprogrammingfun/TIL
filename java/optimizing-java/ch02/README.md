## 인터프리팅과 클래스로딩

JVM은 스택 기반의 해석 머신이다. 레지스터는 없지만 일부 결과를 실행 스택에 보관하며, 이 스택의  맨 위에 쌓인 값을 가져와 계산을 한다. 

JVM 인터프리터의(해석기)의 기본 로직은 평가 스택을 이용해 중간값들을 담아두고 가장 마지막에 실행된 명령어와 독립적으로 프로그램을 구상하는 옵코드(명령 코드)를 하나씩 순서대로 처리하는 while 루프 안의 switch문이다.

### **클래스 로딩 과정**

**(System Class loader은 애플리케이션 클래스로더로 보면 된다)**

![다운로드](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/78543382/7cb5dcdb-f283-4016-a081-273ec073bb3f)

명령을 통해 자바 애플리케이션을 실행하면 os는 가상 머신 프로세스를 구동한다. 자바 가상 환경이 구성되고, 스택 머신이 초기화된 다음 실제로 유저가 작성한 클래스 파일이 실행된다.

애플리케이션의 진입점은 클래스에 있는 main() 메서드이다. 제어권을 이 클래스로 넘기려면 가상 머신 실행이 시작되기 전에 이 클래스를 로드해야 한다. 이때 관여하는 메커니즘이 자바 클래스로딩 메커니즘이다. 자바 프로세스가 새로 초기화되면 사슬 처럼 줄지어 연결된 클래스로더가 차례차례 작동한다. 

1. 제일 먼저 부트스트랩 클래스로더가 실행되며 자바 클래스를 로드할 수 있는 자바 자체의 클래스 로더와 최소한의 자바 클래스(java.lang.Object, Class, ClassLoader)만을 로드한다. Java 8에서는 `jre/lib/rt.jar` 및 기타 핵심 라이브러리와 같은 JDK의 내부 클래스를 로드하고, Java 9이후부터는 더 이상 `/rt.jar`이 존재하지 않으며, `/lib` 내에 모듈화되어 포함되었기 때문에 ClassLoader 내 최상위 클래스들만 로드한다. 
2. 그다음, 확장 클래스로더가 실행된다. 부트스트랩 클래스로더를 자기의 부모로 설정하고, 필요할 때 클래스로딩 작업을 부모에게 넘긴다. 확장 클래스로더는 확장 자바 클래스들을 로드하는데, java.ext.dirs 환경 변수에 설정된 디렉토리의 클래스 파일을 로드하고, 이 값이 설정되어 있지 않은 경우 `${JAVA_HOME}/jre/lib/ext` 에 있는 클래스 파일을 로드한다. 그리 널리 쓰이지는 않지만, 확장 클래스로더를 이용하면 특정한 OS나 플랫폼에 네이티브 코드를 제공하고 기본 환경을 오버라이드 할 수 있다. 
3. 마지막으로, 애플리케이션 클래스로더가 생성되고 지정된 클래스패스에 위치한 유저 클래스를 로드한다. 애플리케이션 클래스로더를 시스템 클래스로더로 부르는 경우도 있는데, 시스템 클래스를 로드하지 않기 때문에 좋지 않은 표현이다. 확장 클래스로더의 자식인 애플리케이션 클래스 로더는 아주 자주 쓰인다. 

자바는 프로그램 실행 중 처음 보는 새 클래스를 디펜던시에 로드한다. 

### 클래스 로더의 동작 방식

**(로딩 요청 위임(Delegate Load Request)과 연관된 이야기이다)**

![다운로드 (1)](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/78543382/4de9442b-a666-4c31-bb0f-c751e7ec425f)


1. JVM의 메소드 영역에 클래스가 로드되어 있는지 확인한다. 만일 로드되어 있는 경우 해당 클래스를 사용한다.
2. 메소드 영역에 클래스가 로드되어 있지 않을 경우, 애플리케이션 클래스로더에 클래스 로드를 요청한다. 
3. 애플리케이션 클래스로더 로더는 확장 클래스 로더에 요청을 위임한다.
4. 확장 클래스 로더는 부트스트랩 클래스 로더에 요청을 위임한다.
5. 부트스트랩 클래스 로더는 부트스트랩 Classpath(JDK/JRE/LIB)에 해당 클래스가 있는지 확인한다. 클래스가 존재하지 않는 경우 확장 클래스 로더에게 요청을 넘긴다. **만약 부트스트랩의 관리 대상 클래스이면 로딩 후 반환합니다.**
6. 확장 클래스 로더는 확장 Classpath(JDK/JRE/LIB/EXT)에 해당 클래스가 있는지 확인한다. 클래스가 존재하지 않을 경우 시스템 클래스 로더에게 요청을 넘긴다. **만약 확장 클래스 로더의 관리 대상 클래스이면 로딩 후 반환합니다.**
7. 애플리케이션 클래스로더는 시스템 Classpath에 해당 클래스가 있는지 확인한다. 클래스가 존재하지 않는 경우 ClassNotFoundException을 발생시킨다. **만약 애플리케이션 클래스로더의 관리 대상 클래스이면 로딩 후 반환합니다.**

## 바이트코드 실행

자바 소스 코드는 실행되기까지 꽤 많은 변환 과정을 거친다. 첫 단계는 자바 컴파일러 javac를 사용해 컴파일하는 것으로, 보통 전체 빌드 프로세스의 한 부분으로 수행한다. 이때 javac가 하는 일은 자바 소스 코드를 바이트코드로 가득 찬 .class 파일로 바꾸는 것이다. javac는 컴파일 하는 동안 최적화는 거의 하지 않기 때문에 그 결과로 생성된 바이트코드는 쉽게 해독할 수 있다. javap 같은 표준 역어셈블리 툴로 열어보면 원래 자바 코드도 어렵잖게 알아볼 수 있다. 

바이트코드는 OS에 독립적으로 동작하기 위해 사용자 언어와 기계어 사이 중간 언어로 특정 컴퓨터 아키텍처에 특정하지 않은 중간 표현형이다.  컴퓨터 아키텍처의 지배를 받지 않기 때문에 이식성이 좋아 컴파일된 소프트웨어는 JVM 지원 플랫폼 어디에서나 실행할 수 있고 자바 언어에 대해서도 추상화되어 있다. 

컴파일러가 생성한 클래스 파일은 다음과 같은 구조를 가지고 있다. 

| 컴포넌트  | 설명 |
| --- | --- |
| 매직넘버 | 0xCAFEBABE |
| 클래스 파일 포맷 버전 | 클래스 파일의 메이저/마이너 버전 |
| 상수 풀 | 클래스 상수들이 모여 있는 위치 |
| 액세스 플래그 | 추상 클래스, 정적 클래스 등 클래스 종류를 표시 |
| this 클래스 | 현재 클래스명 |
| 슈퍼클래스 | 슈퍼클래스명 |
| 인터페이스 | 클래스가 구현한 모든 인터페이스 |
| 필드 | 클래스에 들어 있는 모든 필드 |
| 메서드  | 클래스에 들어 있는 모든 메서드 |
| 속성 | 클래스가 지닌 모든 속성 |

모든 클래스 파일은 이 파일이 클래스 파일임을 나타내는 4바이트 16진수인 0xCAFEBABE라는 매직 넘버로 시작한다. 그 다음 4바이트는 클래스 파일을 컴파일 할 때 꼭 필요한 메이저/마이너 버전 숫자이다.  메이저/마이너 버전은 클래스로더의 호환성 보장을 위해 검사하고 호환되지 않는 버전의 클래스 파일을 만나면 UnsupportedClassVersionError예외가 발생한다.

상수 풀에는 코드 곳곳에 등장하는 상수값이 있다. JVM은 코드를 실행할 때 런타임에 배치된 메모리 대신, 이 상수 풀 테이블을 찾아보고 필요한 값을 참조한다. 

액세스 플래그는 클래스에 적용한 수정자를 결정한다. 플래그 첫 부분은 일반 프로퍼티로 public 클래스인지, 그다음은 상속이 금지된 final 클래스인지를 나타낸다. 또 이 클래스 파일이 인터페이스인지, 추상 클래스인지도 액세스 플래그로 표시한다. 플래그 끝 부분은 클래스 파일이 소스 코드에 없는 합성 클래스인지, 애너테이션 타입인지, 이늄인지를 각각 나타낸다. 

this 클래스, 슈퍼클래스, 인터페이스 엔트리는 클래스에 포함된 타입 계층을 나타내며, 각각 상수 풀을 가리키는 인덱스로 표시한다. 필드와 메서드는 시그니처 비슷한 구조를 정의하고 여기에 수정자도 포함되어있다. 속성 세트는 더 복잡하고 크기가 고정되지 않은 구조를 나타내는데 쓰인다. 

## 핫스팟 입문

자바에 가장 큰 변화를 가져온 것은 자바의 요체인 핫스팟 가상 머신이다. 핫스팟을 처음 선보인 이후로 자바는 c/c++ 같은 언어에 필적할 만한 성능을 자랑하며 진화를 거듭했다. 

![다운로드 (2)](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/78543382/12d679ca-8409-4453-82a2-1609cfdc2534)

언어 및 플랫폼 설계 과정에서 제로 코스트 추상화 사상에 근거한 기계에 가까운 언어와 개발자의 생산성에 무게를 두고 엄격한 저수준 제어라는 일을 대행하는 언어 사이에서 갈등을 겪게 된다. 

> 제로 코스트 추상화 사상? <BR>
어떤 프로그래밍 언어나 라이브러리가 제로코스트 추상화를 제공한다면, 개발자는 해당 함수 또는 메서드가 어떻게 구현되어있는지 신경 쓸 필요 없이 호출만 하면 된다
> 

제로-오버헤드 원칙을 따르는 언어는 컴퓨터와 OS가 실제로 어떻게 작동해야 하는지 개발자가 아주 세세한 저수준 까지 일러주어야 한다. 뿐만 아니라 이런 언어로 작성한 소스 코드를 빌드하면 플랫폼에 특정한 기계어로 컴파일 된다(AOT 컴파일)

> 제로-오버헤드 원칙? <BR>
프로그래머가 직접 코딩 했을 때 보다 더 많은 시간적 공간적인 오버헤드가 있는 기능은 추가해선 안된다.
> 

자바는 제로-오버헤드 추상화 철학을 동조한 적이 없다. 오히려 핫스팟은 프로그램의 런타임 동작을 분석하고 성능에 가장 유리한 방향으로 영리한 최적화를 적용하는 가상 머신이다. 

자바 프로그램은 바이트코드 인터프리터가 가상화한 스택 머신에서 명령어를 실행하며 시작된다. CPU를 추상화한 구조라서 다른 플랫폼에서도 클래스 파일을 문제없이 실행할 수 있지만 최대 성능을 내려면 네이티브 기능을 활용해 CPU에서 직접 프로그램을 실행시켜야 한다. 이를 위해 핫스팟은 프로그램 단위(메서드와 루프)를 인터프리티드 바이트코드에서 네이티브 코드로 컴파일한다. 이를 JIT(Just-In-Time) 컴파일이라고 한다. 핫스팟은 인터프리티드 모드로 실행하는 동안 애플리케이션을 모니터링하면서 가장 자주 실행되는 코드 파트를 발견해 JIT 컴파일을 수행한다. 이렇게 분석을 하는 동안 미리 프로그래밍한 추적 정보가 취합되면서 더 정교하게 최적화를 할 수 있다. 특정 메서드가 어느 한계치를 넘어가면 프로파일러가 특정 코드 섹션을 컴파일/최적화한다. 
 - JIT 컴파일 관련 추가 자료: https://hyeinisfree.tistory.com/26

JIT 방식으로 컴파일하면 여러모로 이점이 많은데, 그 중 가장 큰 장점은 컴파일러가 해석 단계에서 수집한 추적 정보를 근거로 최적화를 결정한다는 것이다. 상황별로 수집한 다양한 정보를 토대로 핫스팟이 더 올바를 방향으로 최적화 할 수 있다. 
자바처럼 프로필 기반 최적화(PGO)를 응용하는 환경에서는 대부분의 AOT 플랫폼에서 불가능한 방식으로 런타임 정보를 활용할 여지가 있으므로 동적 인라이닝 또는 가상 호출등으로 성능을 개선할 수 있다. 또 핫스팟 VM은 시동시 CPU 타입을 정확히 감지해 가능하면 특정 프로레서의 기능에 맞게 최적화를 적용할 수 있다. 

## JVM 메모리 관리

자바는 가비지 수집이라는 프로세스를 이용해 힙 메모리를 자동 관리하는 방식으로 해결한다. 가비지 수집이란 JVM이 더 많은 메모리를 할당해야 할 때 불필요한 메모리를 회수하거나 재사용하는 불확정적 프로세스이다. 가비지 수집이 실행되면 그동안 다른 애플리케이션은 모두 중단되고 하던 일은 멈춰야 한다. 이 중단 시간은 대개 아주 짧지만 애플리케이션 부하가 늘수록 이 시간도 무시할 수 없다.

## 스레딩과 자바 메모리 모델(JMM)

자바는 멀티스레드 프로그래밍을 기본 지원한다. 자바 애플리케이션 스레드는 각각 정확히 하나의 전용 OS 스레드에 대응된다. 공유 스레드 풀을 이용해 전체 자바 애플리케이션 스레드를 실행하는 방안도 있지만 쓸데없이 복잡도만 가중시킬 뿐 만족할 만한 수준의 성능은 나오지 않았다.

자바 멀티스레드 방식은 다음 세 가지 기본 설계 원칙에 기반한다

1. 자바 프로세스의 모든 스레드는 가비지가 수집되는 하나의 공용 힙을 가진다.
2. 한 스레드가 생성한 객체는 그 객체를 참조하는 다른 스레드가 액세스할 수 있다. 
3. 기본적으로 객체는 변경 가능하다. 즉, 객체 필드에 할당된 값은 프로그래머가 애써 final 키워드로 불변 표시하지 않는 한 바뀔 수 있다.

## JVM 구현체 종류

1. OpenJDK 
2. 오라클 자바 
3. 줄루 
4. 아이스티
5. 징
6. J9
7. 애비안
8. 안드로이드 

## JVM 모니터링과 툴링

1. 자바 관리 확장(JMX) : JVM과 그 위에서 동작하는 애플리케이션을 제어하고 모니터링하는 강력한 범용 툴이다. 
2. 자바 에이전트 : 자바 언어로 작성된 툴 컴포넌트로 메서드 바이트코드를 조작한다. 
3. JVM 툴 인터페이스(JVMTI) : JVM의 네이티브 인터페이스이다. 
4. 서비서빌리티 에이전트(SA) : 자바 객체, 핫스팟 자료 구조 모두 표출 가능한 API와 툴을 모아놓은 것이다.

### VisualVM

JVM 어태치 메커니즘을 이용해 실행 프로세스를 실시간 모니터링한다. 

1. 개요 : 자바 프로세스에 관한 요약 정보를 표시한다. 프로세스에 전달한 전체 플래그와 시스템 프로퍼티, 그리고 실행 중인 자바 버전도 정확히 나온다.
2. 모니터 : CPU, 힘 사용량 등 JVM을 고수준에서 원격 측정한 값들이 표시된다. 로드/언로드된 클래스 개수 및 실행 중인 스레드 개수 등 현황도 알 수 있다.
3. 스레드 : 실행 중인 애플리케이션 각 스레드가 시간대별로 표시된다. 스레드별 상태와 짧은 변화 추이를 보면서 필요시 스레드 덤프를 뜰 수 있다. 
4. 샘플러 및 프로파일러 : CPU 및 메모리 사용률에 관한 단순 샘플링 결과가 표시된다.