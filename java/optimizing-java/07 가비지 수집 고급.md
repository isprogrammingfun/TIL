## 가비지 수집 고급

### 트레이드오프와 탈착형 수집기

자바에 가비지 수집기가 있지만 정작 자바/JVM 명세서에는 GC를 구현하는 방법에 대해서는 일언반구도 없다. 실제로 자바 구현체 중에는 가비지 수집 기능이 전혀 없는 것도 있다. 

썬 마이크로시스템즈 환경 내부에서 GC는 탈착형 서브시스템으로 취급된다. 즉, 같은 자바 프로그램이라도 코드 변경 없이 여러 가지 가비지 수집기에서 돌려볼 수 있다. 

탈착형으로 수집기를 쓰는 건, GC가 아주 일반적인 컴퓨팅 기법인 데다 같은 알고리즘이라도 모든 워크로드 유형에 다 적합한건 아니기 때문이다. 따라서 GC 알고리즘은 앞을 다투는 관심사 간의 절충안 내지는 타협점을 반영한다고 볼 수 있다. 모든 GC 관심사를 일제히 최적화하는, 유일무이한 범용 GC 알고리즘은 없다.

개발자는 가비지 수집기 선정 시 다음 항목을 충분히 고민해야 한다.

- 중단 시간(중단 길이 또는 기간)
- 처리율(애플리케이션 런타임 대비 GC 시간%)
- 중단 빈도(수집기 때문에 애플리케이션이 얼마나 자주 멈추는가?)
- 회수 효율(GC 사이클 당 얼마나 많은 가비지가 수집되는가?)
- 중단 일관성(중단 시간이 고른 편인가?)

이 중에서 단연 최고의 관심사는 중단 시간이지만, 대부분 애플리케이션에서 이것 하나만 따로 보면 안된다. 예를 들어, 고도 병렬 배치 처리 시스템이나 빅 데이터 애플리케이션에서는 중단 기간보다 처리율이 더 큰 영향을 미친다. 평범한 배치 잡을 실행하면서 수십 초간 중단이 발생했다고 큰일 나는 건 아니므로 무조건 CPU 효율 및 처리율이 우수한 GC 알고리즘이 중단 시간이 짧은 알고리즘보다 우선이다. 

성능 엔지니어는 수집기 선정 시 다양한 트레이드오프와 관심사를 면밀히 검토애햐 한다. 

### 동시 GC 이론

그래픽/애니메이션 디스플레이 시스템처럼 특화된 시스템은 프레임률이 거의 고정되어 있어서 GC를 규칙적으로 수행할 수 있다. 그러나 범용 가비지 수집기는 중단 결정을 효과적으로 내리는데 참고할 만한 도메인 지식이 없다. 더욱이, 메모리 할당은 불확적성을 유발하는 직접적인 원인으로, 실제로도 많은 자바 응용 시스템에서 들쑥날쑥한 양상을 보인다. 

적절한 계산이 지연되는 건 사실 사소한 단점에 불과하다. 정작 큰 문제는, 가비지 수집이 언제 막간에 끼어들지 도저히 예측할 수 없다는 점이다. 그렇기에 최신 GC 이론은 GC 기술의 가장 큰 걸림돌인, 불확정적 STW 중단 문제를 일단 해결하려고 시도한다. 

동시 수집기를 써버 애플리케이션 스레드의 실행 도중 수집에 필요한 작업 일부를 수행해서 중단 시간을 줄이는 것도 한 방법이다. 물론 이 방법을 사용하면 실제 애플리케이션 작업에 투입 가능한 처리 역량을 빼앗기고 수집하는 코드 로직은 한층 더 복잡해질 것이다. 

다음은 최신 가비지 수집기의 특성과 로직을 이해하는데 필수적인 GC 용어 및 기술이다.

1. **JVM 세이브포인트**

핫스팟 병렬 수집기에서 STW 가비지 수집을 실행하려면 애플리케이션 스레드를 모두 중단 시켜야 한다. JVM이 이런 작업을 어떻게 수행하는가, 라는 질문에 대한 답은 다음과 같다

> JVM은 사실 완전히 선제적인 멀티스레드 환경이 아니다.
> 

그렇다고 JVM이 순수한 협동적 환경이라는 의미는 아닌다. 오히려 그 반대이다. 

여기서 선제적 환경이라는 것은,  JVM이 중간에 끼어들어 우선순위가 낮은 스레드를 끌어 내리고 우선순위가 높은 스레드로 대체하는 일은 하는 환경이다. 반대로 협동적 환경에서는 한 스레드가 제어권을 양보하거나 인터럽트나 시스템 호출 등으로 차단될 때까지 계속 실행되는 환경이다. 

OS는 언제든지 선제 개입을 할 수 있다. 가령, 한 스레드가 자신에게 할당된 타임 슬라이스(시간 할당분)을 다 쓰거나, 스스로 wait() 상태로 잠들 때 그렇게 된다. 이러한 OS 코어 기능처럼 JVM도 뭔가 조정 작업을 할 필요가 있다. 그래서 애플리케이션 스레드마다 세이브포인트라는 특별한 실행 지점을 둔다. 세이브포인트는 스레드의 내부 자료 구조가 훤히 보이는 지점으로, 여기서 어떤 작업을 하기 위해 스레드는 잠시 중단될 수 있다. 

예를 들어 풀 STW 가비지 수집기의 경우, 이 수집기가 작동하려면 안정된 객체 그래프가 필요하다. 즉, 전체 애플리케이션 스레드를 반드시 중단시켜야 한다. GC 스레드가 OD에게 무조건 애플리케이션 스레드를 강제 중단시켜달라고 요청할 방법은 없기 때문에 애플리케이션 스레드는 반드시 서로 공조해야 한다. JVM은 다음 두 가지 규칙에 따라 세이프포인트를 처리한다.

- JVM은 강제로 스레드를 세이프포인트 상태로 바꿀 수 없다.
- JVM은 스레드가 세이프포인트 상태에서 벗어나지 못하게 할 수 있다.

따라서 세이프포인트 요청을 받았을 때 그 지점에서 스레드가 제어권을 반납하게 반드는 코드(베리어)가 VM 인터프리터 구현제 어딘가에 있어야 한다. 

JIT 컴파일한 메서드에도 생성된 기계어 안에 이런 배리어가 꼭 들어가 있어야 한다. 다음은 세이프포인트 상태로 바뀌는 몇 가지 일반적인 경우이다.

- JVM이 전역 세이프포인트 시간 플래그를 세팅한다.
- 각 애플리케이션 스레드는 폴링하면서 이 플래그가 세팅됐는지 확인한다.
- 애플리케이션 스레드는 일단 멈췄다가 다시 깨어날 때까지 대기한다.

세이프포인트 시간 플래그를 세팅하면 모든 애플리케이션 스레드는 반드시 멈춰야한다. 일찍 멈춘 스레드는 느리게 멈추는 다른 스레드를 기다려야 한다. 

일반 애플리케이션 스레드는 이런 식으로 폴링을 한다. 인터프리터에서 바이트코드 2개를 실행할 때마다 체크한다. 컴파일드 코드에서는, 보통 컴파일드 메서드 밖으로 나가거나 분기가 루프 처음으로 회귀하는 지점에 JIT 컴파일러가 세이프포인트 폴링 코드를 삽입한다. 스레드가 세이프포인트에 이르기까지 꽤 많은 시간이 소요될 수 있고, 이론적으로 절대 멈추지 않을 가능성도 있다. 

다음 각 경우에 스레드는 자동으로 세이프포인트 상태가 된다

- 모니터에서 차단된다.
- JNI 코드를 실행한다.

다음 경우에는 스레드가 꼭 세이브포인트 상태가 되는 건 아니다.

- 바이크코드를 실행하는 도중이다.
- OS가 인터럽트를 걸었다.
1. **삼색 마킹**

삼색 마킹 알고리즘은 동시성 알고리즘과 GC의 정확성을 증명했다. 이후 삼색 마킹 알고리즘은 가비지 수집 이론에서 중요한 위치를 차지했다.

삼색마킹 알고리즘 작동 원리는 다음과 같다.

- GC 루트를 회색 표시한다.
- 다른 객체는 모두 흰색 표시한다.
- 마킹 스레드가 임의의 회색 노드로 이동한다.
- 마킹 스레드가 흰색 표시된 자식 노드가 있는 노드를 만나면, 먼저 그 자식 노드를 모두 회색 표시한 뒤, 해당 노드를 검은색 표시한다.
- 회색 노드가 하나도 남지 않을 때까지 위 과정을 되풀이 한다.
- 검은색 객체는 모두 접근 가능한 것이므로 살아남는다.
- 흰색 노드는 더 이상 접근 불가한 객체이므로 수집 대상이 된다.

![122766159-2c221000-d2dc-11eb-8957-90d6f3860937](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/78543382/6a6d76b3-ef2e-4b82-9925-78a06f523f26)


여기서 검은색, 흰색, 회색은 다음과 같은 뜻을 나타낸다.

1. 검은색 (Black): 이미 가비지 컬렉션에 의해 스캔되고 처리 중인 객체. 검은색으로 표시된 객체들은 현재 가비지 컬렉션 중에 있으며, 가비지로 인식되지 않았음을 나타낸다.
2. 흰색 (White): 아직 스캔되지 않은 객체. 흰색으로 표시된 객체들은 가비지 컬렉션의 스캔 대상이 될 수 있는 객체로, 가비지인지 아닌지 판단되지 않은 상태이다.
3. 회색 (Gray): 초기 스캔이 시작될 때 흰색 객체 중에서 스캔이 필요한 객체들을 나타낸다. 즉, 회색으로 표시된 객체들은 아직 검사 중인 객체로, 이들은 나중에 스캔되며 검은색으로 변경된.

동시 수집은 STAB(일단 스냅샷 뜨기) 라는 기법을 적극 활용한다. 즉, 수집 사이클을 시작할 때 접근 가능하거나 그 이후에 할당된 객체를 라이브 객체로 간주하는 것이다.  그래서 삼식 마킹 알고리즘은 사소하지만 몇 가지 단점이 있다. 가령, 변경자 스레드가 수집을 하는 도중에는 검은색 상태, 수집을 안 하는 동안에는 흰색 상태로 새 객체를 생성할 수 있다. 

삼색 마킹 알고리즘에서 실행 중인 애플리케이션 스레드가 변경한 것 때문에 라이브 객체가 수집되는 현상을 방지하려면 몇 가지 로직이 더 추가돼야 한다. 동시 수집기에서는 마킹 스레드가 삼색 알고리즘을 실행하는 도중에도 애플리케이션 스레드가 계속 객체 그래프를 변경하기 때문이다. 이미 검은색으로 표시한 객체를 마킹 스레드가 나중에 흰색 객체를 참조하도록 바꾸는 상황이 연출될 수도 있다. 

이는 여러가지 방법으로 해결할 수 있다. 우선, 객체 색깔을 검은색→회색으로 바꾸고 변경자 스레드가 업데이트하며 처리할 노드 세트에 도로 추가하면 된다. 이처럼 업데이트 시 쓰기 베리어를 이용하는 방법은 전체 마킹 사이클 동안 삼색을 그대로 유지할 수 있기 때문에 알고리즘 측면에서 훌륭하다.

> 동시 마킹 도중에는 절대로 검은색 객체 노드가 흰색 색체 노드를 가리킬 수 없다.\
> 

이 삼색 불변의 원칙을 위배할지 모를 모든 변경 사항을 큐 형태로 넣어두고, 주 단계가 끝난 다음 부차적인 조정 단계에서 바로 잡는 방법도 있다. 필요한 락킹 개수 등 성능 기준에 따라 삼색 마킹 문제를 해결하는 방법은 수집기마다 다르다. 

### CMS

CMS 수집기는 중단 시간을 아주 짧게 하려고 설계된, 테뉴어드(올드) 공간 전용 수집기이다. 보통 영 세대 수집용 병렬 수집기를 조금 변형한 수집기와 함께 사용한다.

CMS는 중단 시간을 최소화하기 위해 애플리케이션 스레드 실행 중에 가급적 많은 일을 한다. 마킹은 삼색 마킹 알고리즘에 따라 수행하므로 수집기가 힙을 탐색하는 도중에도 객체 그래프가 변경될 수 있다. 따라서 CMS는 가비지 수집의 두 번째 원칙인 “아직 살아 있는 객체를 수집하면 안 된다”라는 원칙을 위반하지 않도록 반드시 레코드를 바로잡아야 한다. CMS의 수행 단계는 다음과 같다.

- 초기 마킹(STW)
- 동시 마킹
- 동시 사전 정리
- 재마킹
- 동시 스위프
- 동시 리셋

초기 마킹과 재마킹 단계 동안 모든 애플리케이션 스레드가 멈추고, 나머지 단계에서는 애플리케이션 스레드와 병행하여 GC를 수행한다. 전체적으로 한 차례 긴 STW 중단을 일반적으로 매우 짧은 두 차례 STW 중단으로 대체한 셈이다. 

초기 마킹 단계의 목적은, 해당 영역 내부에 위치한 확실한 GC 출발점(내부 포인터라고 하며 수집 사이클 목적상 GC 루트와 동등함)을 얻는 것이다. 이렇게 접근하면 마킹 단계에서 다른 메모리 영역은 신경 쓸 필요 없이 하나의 GC 풀에만 집중할 수 있기 때문에 유리하다. 

초기 마킹이 끝나면 동시 마킹 단계로 넘어간다. 삼색 마킹 알고리즘을 힙에 적용하면서 나중에 조정해야 할지 모를 변경 사항을 추적한다. 

동시 사전 정리 단계의 목표는 재마킹 단계에서 가능한 한 STW 시간을 줄이는 것이다. 재마킹 단계는 카드 테이블을 이용해 변경자 스레드가 동시 마킹 단계 도중 영향을 끼친 마킹을 조정한다. 

대부분 워크로드에 CMS를 적용하면 다음과 같은 효과가 있다.

- 애플리케이션 스레드가 오랫동안 멈추지 않는다.
- 단일 풀 GC 사이클 시간이 더 길다.
- CMS GC 사이클이 실행되는 동안, 애플리케이션 처리율은 감소한다.
- GC가 객체를 추적해야 하므로 메모리를 더 많이 쓴다.
- GC 수행에 훨씬 더 많은 CPU 시간이 필요하다.
- CMS는 힙을 압착하지 않으므로 테뉴어드 영역은 단편화될 수 있다.

**CMS 작동 원리**

CMS는 대부분 애플리케이션 스레드와 동시에 작동한다. 기본적으로 가용 스레드 절반을 동원해 GC 동시 단계를 수행하고 나머지 절반은 애플리케이션 스레드가 자바 코드를 실행하는 데 쓴다. 그래서 어쩔 수 없이 새로운 객체가 할당된다. 

만약 CMS 실행 도중 에덴 공간이 꽉 차버리면 애플리케이션 스레드가 더 이상 진행할 수 없으니  실행이 중단되고 CMS 도중 영 GC가 일어날 것이다. 그런데 이 영 GC는 코어 절반만 사용(나머지 절반은 CMS)하므로 병렬 수집기의 영 GC보다 더 오래 걸린다.

평상시에는 영 수집 이후 극히 일부 객체만 테뉴어드로 승격되고, CMS 올드 수집을 하면 테뉴어드 공간이 정리된다. 그런 다음 애플리케이션은 다시 정상 모드로 돌아가 전체 코어를 이용해 다시 처리하기 시작한다. 하지만 할당률이 급증하면 영 수집 시 조기 승격이 일어난다. 

![122772106-013aba80-d2e2-11eb-8ec8-871056e3488d](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/78543382/7a10f475-b4bf-4a63-b7c1-ad6cc00c37af)


급기야 영 수집 후 승격된 객체가 너무 많아 테뉴어드 공간조차 부족한 사태가 벌어지는데, 이 현상을 동시 모드 실패(CMF)라고 하며, JVM은 어쩔 수 없이 풀 STW를 유발하는 ParallelOld GC 수집 방식으로 돌아간다. 할당압이 너무 높은 나머지 새로 승격된 객체를 올드 세대에 수용할 여력이 소진되기 전에 CMS가 올드 세대 처리를 완료한 시간이 없는 상태에 이른 것이다.

CMF가 자주 일어나지 않게 하려면 테뉴어드가 꽉 차기 전에 CMS가 수집 사이클을 개시해야 한다. CMS가 수집을 시작하는 테뉴어드의 힙 점유 수준은 힙 상태에 따라 달라진다. 스위치로 지정할 수도 있고, 디폴트는 75% 테뉴어드이다. 

힙 단편화는 CMF를 유발하는 또 다른 원인이다. ParallelOld GC와 달리 CMS는 테뉴어드를 압착하지 않는다. 즉, 테뉴어드의 빈 공간은 단일 연속 블록이 아니기 때문에 CMS가 작업을 마친 후 승격된 객체를 기존에 들어찬 객체 사이사이로 넣어야 한다. 그러다 더 이상 객체를 끼워 넣을 공간이 부족하면 객체를 테뉴어드로 승격시킬 수 없게 된다.  

유일한 해결책은 앞서 언급했듯이 압착 수집기인 ParallelOld GC로 풀 수집해서 객체를 승격시킬 만한 연속 공간을 충분히 확보하는 한 가지뿐이다.

이렇게 영 수집이 CMS보다 더 빠르거나 힙 단편화가 발생하면 풀 STW ParallelOld GC 수집으로 회귀할 수밖에 없는데, 애플리케이션 입장에서는 중대한 사건이다. CMF를 방지하기 위해 CMS를 적용한 저지연 애플리케이션에서는 사실상 튜닝 자체가 주요 이슈이다. 

CMS는 내부적으로 프리 리스트를 이용해 사용 가능한 빈 공간을 관리한다. 동시 스위프 단계에서 스위퍼 스레드가 여유 공간을 더 큰 덩어리로 만들고 단편화로 인해 CMF가 발생하지 않도록 연속된 빈 블록들을 하나로 뭉친다. 하지만 스위퍼는 변경자와 동시게 작동하므로 스레드가 서로 적절히 동기화되지 않는 한 새로 할당된 블록이 잘못 스위프될 가능성이 있다. 이런 일이 없게끔 스위퍼 스레드는 작업 도중 프리 리스트를 잠근다. 

**CMS 기본 JVM 플래그**

```java
-XX:+UseConcMarkSweepGC
```

### G1

처음부터 중단 시간이 짧은 새로운 수집기로 설계된 G1은 다음과 같은 특성이 있다.

- CMS 보다 훨씬 튜닝하기 쉽다.
- 조기 승격에 덜 취약하다.
- 대용량 힙에서 확장성(특히 중단시간)이 우수하다.
- 풀 STW 수집을 없앨 수(또는 풀 STW 수집으로 되돌아갈 일을 확 줄일 수) 있다.

하지만 시간이 지나면서 G1은 대용량 힙에서 중단 시간이 짧은 범용 수집기로 점점 더 굳혀졌다.

G1은 지금까지의 세대 개념을 다른 관점에서 다시 생각해 설계한 수집기이다. 따라서 병렬/CMS 수집기와는 달리 세대마다 경계가 뚜렷한, 연속된 메모리 공간이 없고 반구형 힙 레이아웃 방식과도 전혀 무관하다. 

**G1 힙 레이아웃 및 영역**

G1 힙은 영역(리전)으로 구성된다. 영역은 디폴트 크기가 1메가바이트(힙이 클수록 크기가 커짐)인 메모리 공간이다. 영역을 이용하면 세대를 불연속적으로 배치할 수 있고, 수집기가 매번 실행될 때마다 전체 가비지를 수집할 필요가 없다. 

![122908648-57b20280-d38f-11eb-82e7-789f038e090a](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/78543382/8c52b05f-e81d-4399-818f-eed1b3172821)


G1 알고리즘에서는 1,2,4,8,16,32,64 메가바이트 크기의 영역을 사용할 수 있다. 기본적으로 힙에는 2048~4095개의 영역이 있고, 이 개수에 따라 영역 크기도 조정된다.

**G1 알고리즘 설계**

G1 수집기가 하는 일은 대략 다음과 같다

- 동시 마킹 단계를 이용한다
- 방출 수집기
- 통계적으로 압착한다

G1 수집기는 워밍업을 하는 동안, GC 사이클이 한번 돌 때마다 얼마나 많은 일반 영역에서 가비지를 수집할 수 있는지 그 수치를 보관한다. 제일 마지막에 GC가 발생한 이후로 새로 할당된 객체를 감당하기에 충분한 메모리를 수집할 수 있다면, G1을 할당보다 뒤처지지 않는 것이다.

G1에서도 에덴, 서바이버 영역으로 이루어진 영 세대 개념은 같지만, 세대를 구정하는 영역이 연속되어 있지 않다는 차이점이 있다. 영 세대의 크기는 전체 중단 시간 목표에 따라 조정된다. 

G1 수집기에는 핫스팟 병렬/CMS 수집기에서 활용하는 장치인 카드테이블과 비슷한  기억 세트(RSet)라는 장치로 영역을 추적한다. RSet은 영역별로 하나씩, 외부에서 힙 영역 내부를 참조하는 레퍼런스를 관리하기 위한 장치이다. 덕분에 G1은 영역 내부를 바라보는 레퍼런스를 찾으려고 전체 힙을 다 뒤질 필요 없이 RSet만 꺼내 보면 된다.

RSet, 카드 테이블은 모두 부유 가비지 라는 GC  문제를 해결하는데 유용하다. 부유 가비지는 현재 수집 세트 외부에서 죽은 객체가 참조하는 바람에 이미 죽었어야 할 객체가 계속 살아 있는 현상이다. 즉, 전역 마킹상으로는 죽은 객체처럼 보일 수 있지만, 사용한 루트 세트에 따라 범위가 제한적인 로컬 마팅상에서는 살아 있는 객체로 잘못 인식되는 것이다.

**G1 단계**

G1 수집 단계는 다음과 같다.

- 초기 마킹(STW)
- 동시 루프 탐색
- 동시 마킹
- 재마킹
- 정리

동시 루프 탐색은 초기 마킹 단계의 서바이버 영역에서 올드 세대를 카리키는 레퍼런스를 찾는 동시 단계로, 반드시 다음 영 GC 탐색을 시작하기 전에 끝내야 한다. 마킹 작접은 재마킹 단계에서 완료된다.

레퍼런스를 처리하고 SATB 방식으로 정리하는 작업도 재마킹 단계에서 한다. 

정리 단계는 어카운팅 및 RSet 씻기 태스크를 수행하며 대부분 STW를 일으킨다. 어카운팅은 이제 완전히 자유의 몸이 되어 에덴 영역에서 재사용 준비를 마친 영역을 식별하는 작업이다.

**G1 기본 JVM 플래그**

```java
+XX:UseG1GC
```

### 셰난도아

셰난도아는 레드햇 진영에서 OpenJDK 프로젝트 일환으로 제작한 자체 수집기이다. 

셰난도아 역시 G1처럼 주목표는 중단 시간 단축이다. 이를 달성하고자 셰난도아는 동시 압착을 한다. 수집 단계는 다음과 같다.

- 초기 마킹(STW)
- 동시 마킹
- 최종 마킹(STW)
- 동시 압착

셰난도아의 가장 두드러진 특징은 브룩스 포인터이다. 이 포인터는 객체 당 메모리 워드를 하나 더 써서 이전 가비지 수집 단계에서 객체가 재배치됐는지 여부를 표시하고 새 버전 객체 콘텐츠의 위치를 가리킨다. 이런 매커니즘을 포워딩 포인터라고도 부른다. 재배치되지 않은 객체의 브룩스 포인터는 그냥 메모리 다음 워드를 가리킨다. 

브룩스 포인터는 하드웨어 수준에서 지원되는 CAS 기능에 의존하여 포워딩 주소를 아토믹하게 수정한다.

![123225372-a08fc580-d50d-11eb-99d2-51fdfaf2a2ff](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/78543382/7b9deb27-d3a5-4fd2-8e16-b47f701498d3)

동시 마킹 단계에서는 힙을 죽 훑어 살아 있는 객체를 모두 마킹한다. 포워딩 포인터가 있는 oop를 가리키는 객체 레퍼런스가 있으면 새 oop 위치를 직접 참조하도록 레퍼런스를 수정한다. 최종 마킹 단계에서 셰난도아는 STW하고 루트 세트를 재탐색한 후, 방축된 사본을 가리키도록 루트를 복사하고 수정한다. 

**동시 압착**

GC 스레드는 다음과 같이 방출한다.

- 객체를 TLAB로 복사한다.
- CAS로 브룩스 포인터가 추측성 사본을 가리키도록 수정한다.
- 이 작업이 성공하면 압착 스레드가 승리한 것으로, 이후 이 버전의 객체는 모두 브룩스 포인터를 경유해서 액세스하게 된다.
- 이 작업이 실패하면 압착 스레드가 실패한 것으로, 추측정 사본을 원상복구하고 승리한 스레드가 남긴 브룩스 포인터를 따라간다.

셰난도아는 동시 수집기라서 수집 사이클 동안에는 애플리케이션 스레드가 생성하는 가비지가 더 많다. 그래서 애플리케이션 실행 중에 수집을 할당 페이스에 맞춰야 한다. 

셰난도아 얻기

```java
-XX:+UseShenandoahGC
```

### C4(아줄 징)

셰난도아처럼 동시 압착 알고리즘을 사용하지만, 징은 브룩스 포인터 대신 64비트 워드 하나도 이루어진 객체 헤더를 쓴다. 이 단일 워드 헤더에는 klass 포인터 대신 kid가 들어 있다.

주소 비트 대신, 로드값 배리어용 oop 레퍼런스 비트 일부를 사용한다.

헤더의 하위 32비트에는 락 정보를 보관한다. 락 상태와 관련 추가 정보가 여기에 담긴다.  

징은 처음부터 64비트 아키텍처 전용으로 설계된 까닭에 메타데이터를 31비트에 끼워 맞출 필요가 없다. 

**로드값 배리어**

셰난도아 수집기에서는 애플리케이션 스레드에 의해 재배치됐을지 모를 객체의 레퍼런스를 로드할 가능성이 있으므로 브룩스 포인터를 이용해 새 위치를 추적한다. 로드값 배리어는 이런 패턴을 지양하고 로드한 레퍼런스 각자의 로딩이 끝나자마자 현재 객체 위치를 직접 가리키게 만들자는 아이디어이다. 아줄에서는 이것을 자가 치유 배리어라고 부른다.

수집기가 재배치한 객체 레퍼런스를 징이 따라가면 무엇보다 해당 객체의 새 위치를 먼저 바라보도록 애플리케이션 스레드가 레퍼런스를 수정한다. 이로 인해 각 레퍼런스가 최대 한번만 수정되기 때문에 다시 쓸 일이 없는 레퍼런스는 아무 작업도 하지 않는다. 

헤더 워드뿐만 아니라, 징의 객체 레퍼런스는 객체의 GC 상태와 관련된 메타데이터를 나타내는 일부 레퍼런스 비트를 사용한다. 레퍼런스 자신의 비트를 사용하니까 단일 헤더 워드 비트를 통째 다 쓰는 것보다 공간을 절약할 수 있다. 

```
struct Reference{
  unsigned inPageVA : 21; // 0-20 비트
  unsigned PageNumber : 21; // 21-41비트
  unsigned NMT : 1; // 42비트
  unsigned SpaceID : 2; // 43-44비트
  unsigned unused : 19; // 45-63비트
};

int Expected_NMT_Value[4]={0,0,0,0};

// 공간 ID값
// 00 NULL 및 논힙 포인터
// 01 올드 세대 레퍼런스
// 02 뉴 세대 레퍼런스
// 11 사용 안함
```

NMT 메타데이터 비트는 현재 수집 사이클에서 객테가 이미 마킹됐는지 여부를 나타낸다. 

C4는 살아 있는 객체를 마킹할 용도로 타깃 상태를 관리하는데, 객체가 마킹 도중 재배치되면 NMT 비트를 타깃 상태와 동일하게 세팅한다. 수집 사이클이 끝날 때 C4 가 타깃 상태 비트를 뒤집기 때문에 생존한 객체는 모두 다음 사이클로 넘어갈 준비가 끝난다.

C4의 전체 GC 단계는 다음과 같다.

- 마킹
- 재배치
- 재매핑

G1 처럼 재배치 단계에서는 가장 성긴 페이지에 집중된다. 

C4는 교대 압착이라는 기술로 연속적으로 압착한다. 물리 메모리 주소와 가장 메모리 주소 간의 단절이라는, 가상 메모리 체계의 특성을 활용하는 기술이다. 평상시 가상 메모리 서브시스템은 프로세스 주소 공간에 가상 페이지와 하부 물리 페이지 사이의 매칭 정보를 관리한다.

징의 방출 기법에 따라 객체는 다른 페이지에 복사되는 형태로 재배치되는데, 그 결과 자연스럽게 서로 다른 물리 주소에 대응된다. 

징의 C4 수집기는 항상 두 가지 수집 알고리즘(영 객체용 하나, 올드 객체용 하나)을 실행한다. 따라서 오버헤드는 어쩔 수 없이 발생하지만, 동시 수집기 튜닝 시 수집기가 백투백 모드로 실행된다고 보는 것이 오버헤드와 용량 계획 면에서 유리하다. 

### 밸런스드(IBM J9)

밸런스드는 영역 기반 수집기로, 64비트 J9 JVM에서 사용할 수 있고 4기가 바이트 이상의 힙에 맞게 설계됐다. 다음은 이 수집기의 주요 목표이다.

- 대용량 자바 힙에서 중단 시간이 길어지는 현상을 개선한다.
- 중단 시간이 최악인 경우를 최소화한다.
- 불균일 기억 장치 액세스 성능을 인지하여 활용한다.

첫 번째 목표를 달성하기 위해 힙을 여러 개의 영역으로 분할해 각자 독립적으로 관리/수집한다.

밸런스드 수집기도 G1 처럼 최대 2,048개 영역을 관리하며 이 개수에 맞게 영역 크기를 정한다. 영역 크기는 G1과 똑같이 2의 제곱수지만 최소 512킬로바이트 이상은 되어야 한다.

밸런스드도 세대별 영역 기반의 수집기이므로 영역별로 나이가 있고 새 객체는 나이가 0인 영역(에덴)에 할당한다. 에덴이 꽉 차면 수집이 일어나는데, IBM 용어로는 부분 가비지 수집(PGC)이라고 한다. 

PGC는 에덴 영역을 모두 수집하는 STW 작업으로, 나이가 더 많이 든 영역도 그럴만한 가치가 있다고 판단되면 추가로 수집한다. 이런 면에서는 G1의 혼합 수집과 비슷하다.

여타 J9 GC 정책과 다르게 클래스 언로딩을 점진적으로 수행할 수 있다는 이점도 있다. 밸런스트 수집기는 PGC 도중 현재 수집 대상의 일부인 클래스로더를 수집할 수 있다. 전역 수집하는 동안에만 클래스로더 수집이 가능한 다른 J9 수집기와는 차이가 난다.

물론, 단점도 있다. PGC는 스스로 수집하기로 결정한 영역만 바라볼 수 있으므로 부유 가비지가 생길 수 있다. 그래서 밸런스드 수집기는 전역 마킹 단계(GMP)를 따로 두고 전체 자바 힙을 탐색하면서 수집할 죽은 객체를 표시하는, 부분적인 동시 작업을 수행한다. GMP가 끝난 후 PGC를 수행하는 것이다. 따라서 힙 내 부유 가비지 양은 마지막 GMP가 시작된 이후로 죽은 객체 수를 초과할 수 없다. 

밸런스드 수집기는 전역 가비지 수집(GGC)라는 작업도 수행한다. GGC는 힙을 압착하는 풀 STW 수집으로, 핫스팟에서 CMF 발생 시 일어나는 풀 수집과 비슷하다. 

**J9 객체 헤더**

기본 J9 객체 헤더는 64비트 클래스 슬롯이다. 객체 유형에 따라 헤더에 슬롯이 더 추가될 수도 있다.

- 동기화한 객체에는 모니터 슬롯이 있다.
- JVM 내부 구조에 편입된 객체에는 해시 슬롯이 있다.

모니터 슬롯, 해시 슬롯은 객체 헤더와 꼭 붙어 있을 필요는 없다. 객체 어디에나 보관할 수 있어서 정렬 때문에 공간을 낭비할 일도 없다. 

클래스 슬롯의 최상위 24비트는 클래스 구조를 가리키는 포인터로, 자바 8의 메타 공간과 비슷한 오프-힙 메모리이다. 

**밸런스드에서 큰 배열 처리하기**

자바에서 큰 배열을 할당하면 충분히 큰, 연속된 공간을 찾아야 하므로 대부분 압착 수집이 일어난다. 여유 공간을 큰 덩어리로 합쳐도 할당 공간이 부족해서 CMF가 발생할 때도 있다. 

영역 기반의 수집기에서 하나의 영역보다 더 큰 자바 배열 객체를 할당하지 말라는 법은 없다. 그래서 밸런스드 수집기는 불연속된 여러 덩이에 큰 배열을 할당할 수 있도록 어레이릿이라는 형태로 나타낸다. 힙 객체가 여러 영역에 걸쳐있는 유일한 상황이다. 

어레이릿은 유저 자바 코드에서는 안 보이고 JVM이 투명하게 처리한다. 할당기는 큰 배열을 스파인이라는 주 객체와 배열 리프들로 표현한다. 배열 리프는 실제 배열 엔트리를 담고 있고, 스파인 엔트리는 이 배열 리프들을 가리키는 자료 구조이다. 따라서 한 단계 더 에두를 오버헤드만 추가하는 정도로 엔트리를 읽을 수 있다. 

여러 영역에 걸쳐 부분 GC를 수행하면 참조 객체, 피참조 객체 영역 정보를 관리하는 오버헤드가 발생하므로 전체 GC 소요 시간은 더 걸리지만 평균 중단 시간은 줄어든다.

무엇보다 중요한 건, 힙이 꽉 찼을 때 최후의 수단으로 동원하는 풀 STW 수집이나 압착이 필요한 경우의 수가 현저히 줄어든다는 점이다. 

밸런스드 수집기는 영역 및 불연속된 큰 배열을 관리하는 오버헤드가 있으므로 중단 시간을 줄이는 일이 직접적인 처리율을 높이는 것보다 더 중요한 애플리케이션이 적합하다. 

**NUMA와 밸런스드**

NUMA는 일반적으로 중대형 서버용 멀티프로세스 시스템에서 사용하는 메모리 아키텍처이다. 이런 시스템에서는 메모리와 프로세스 사이에 거리라는 개념이 있어서 프로세스와 메모리를 노드로 묶는다. 어떤 노드에 있는 프로세스가 다른 노드에 있는 메모리에 액세스하는 건 얼마든지 가능하지만, 아무래도 로컬 메모리 즉, 같은 노드에 속한 메모리에 액세스할 때 가장 빠를것이다.

여러 NUMA 노드에 걸쳐 실행되는 JVM에서 밸런스드 수집기는 노드별로 자바 힙을 분리할 수 있다. 애플리케이션 스레드는 자신이 선호하는 특징 노드에서 실행되고 그 노드에 속한 메모리 영역에 객체를 할당하도록 조정된다. 

또 부분 가비지 수집기는 어떤 객체를 그 자신을 참조하는 다른 객체, 스레드와 가급적 가까운 위치에 두려고 한다. 그러면 스레드가 참조하는 메모리가 로컬일 가능성이 커져서 성능이 좋아진다. 물론, 이 과정은 애플리케이션 모르게 일어난다.

### 레거시 핫스팟 수집기

**Serial 및 Serial Old**

Serial/Serial Old GC는 Parallel/ParallelOld GC와 작동 원리는 거의 같지만, CPU 한 코어만 사용해 GC를 수행한다. 물론 동시 수집이 안 되고 풀 STW을 일으킨다. 

**증분 CMS**

증분 CMS는 예전에 동시 수집을 시도했던 수집기이다. CMS에 도입하려고 했던 일부 아이디어는 훗날 G1에도 영향을 미쳤다. 증분 CMS는 다음 스위치로 킨다.

```java
-XX:+CMSIncrementalMode
```

**디프리케이트되어 사라진 GC 조합**
| 조합 | 플래그 |
| --- | --- |
| DefNew + CMS | -XX:-UseParNewGC  
-XX:+UseConcMarkSweepGC |
| ParNew + SerialOld | -XX:+UseParNewGC |
| ParNew + iCMS | -Xincgc |
| ParNew + iCMS | -XX:+CMSIncrementalMode  <BR>-XX:+UseConcMarkSweepGC |
| ParNew + iCMS | -XX:+CMSIncrementalMode <BR>-XX:+UseConcMarkSweepGC <BR>-XX:-UseParNewGC |
| CMS foreground | -XX:+UseCMSCompactAtFullCollection |
| CMS foreground | -XX:+CMSFullGCsBeforeCompaction |
| CMS foreground | -XX:+UseCMSCollectionPassing |
**엡실론**

엡실론 수집기는 레거시 수집기는 아니지만, 어느 운영계 환경에선 절대 사용해선 안된다. 

엡실론은 테스트 전용으로 설계된, 아무 일도 안 하는 시험 수집기이다. 실데로 가비시 수집 활동일 일체 하지 않는다. 따라서 엡실론이 실행되는 동안 할당된 힙 메모리는 한 바이트, 한 바이트가 사실상 메모리 누수이다. 절대 회수할 수 없는 메모리라서 JVM은 결국 언젠가 메모리가 고갈되어 멎게 된다.

이런 수집기는 다음과 같은 작업에선 유용할 것이다.

- 테스트 및 마이크로벤치마크 수행
- 회귀 테스트
- 할당률이 낮거나 0인 자바 애플리케이션 또는 라이브러리 코드의 테스트

JMH 테스트를 할 때는 성능을 저해할 만한 GC 이벤트를 확실히 배제할 수 있어 좋다. 메모리 할당 회귀 테스트 또한 작업이 한결 수월해질 것이다. 개발자는 제한된 할당 개수만 받도록 엡실론을 구성한 상태에서 결국 힙 고갈로 인해 더 이상 할당할 수 없을 때까지 테스트를 돌려볼 수 있다.

끝으로, VM-GC 인터페이스를 개발하는 과정에서 인터페이스 자체를 점검하는 최소한의 테스트 케이스를 수립할 때 엡실론은 유용하다.