## GC 로깅, 모니터링, 튜닝, 툴

### GC 로깅 개요

GC 로그는 더 없이 훌륭한 원천 정보이다. 특히, 시스템이 내려간 원인의 단서를 찾는 ‘콜드 케이스’ 분석을 할 때 매우 유용하다. 파일에 쓰인 로그를 분석하는 작업이므로 애플리케이션 프로세스가 살아 있지 않아도 된다. 모든 중요한 애플리케이션에는 다음 두 가지를 설정해야 한다.

- GC 로그를 생성한다.
- 애플리케이션 출력과는 별도로 특정 파일에 GC 로그를 보관한다.

GC 로깅은 사실 오버헤드가 거의 없는 것이나 다름없으니 주요 JVM 프로세스는 항상 로깅일 켜놓아야 한다. 

**GC 로깅 켜기**

가장 먼저 애플리케이션 시작 시 다음 스위치를 추가한다. 자바/JVM 애플리케이션이라면 무조건 켜야 하는 필수 GC 로깅 플래그이다.

```
-Xloggc:gc.log -XX:+PrintGCDetails -XX:+PrintTenuringDistribution
-XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps
```

각각 자세한 용도는 다음과 같다.

| 플래그 | 작용 |
| --- | --- |
| -Xloggc:gc.log | GC 이벤트에 로깅할 파일을 지정한다.  |
| -XX:+PrintGCDetails | GC 이벤트 세부 정보를 로깅한다. |
| -XX:+PrintTenuringDistribution | 툴링에 꼭 필요한, 부가적인 GC 이벤트 세부 정보를 추가한다. |
| -XX:+PrintGCTimeStamps | GC 이벤트 발생 시간을 (VM 시작 이후 경과한 시간을 초 단위로) 출력한다. |
| -XX:+PrintGCDateStamps | GC 이벤트 발생 시간을 (벽시계 시간 기준으로) 출력한다.  |

다음은 필수 플래그에서 성능 엔지니어가 주의해야 할 사항이다.

- 기존 플래그 verbose:gc는 지우고 대신 PrintGCDetails를 사용한다.
- PrintTenuringDistribution은 다소 독특한 플래그로, 이 플래그가 제공하는 정보를 사람이 이용하기는 어렵다. 중요한 메모리압(메모리 할당 압박) 효과, 조기 승격 등의 이벤트 계산 시 필요한 기초 데이터를 제공한다.
- PrintGCDateStamps와 PrintGCTimeStamps는 둘 다 필요하다. 전자는 GC 이벤트와 애플리케이션 이벤트를 후자는 GC와 다른 내부 JVM 이벤트를 각각 연관짓는 용도로 쓰인다.

로그를 이 정도로 자세히 남겨도 JVM 성능에 이렇다 할 영향은 없다. 물론 생성되는 로그량은 할당률, 사용 중인 수집기, 힙 크기(힙이 작으면 더 자주 GC가 발생하므로 로그가 더 자주 쌓임)에 따라 달라진다. 

필수 플래그 이외에도 로그 순환 관련 플래그가 있다. 이는 운영계 환경에 요긴하다.

| 플래그 | 적용 |
| --- | --- |
| -XX:+UseGCLogFileRotation | 로그 순환 기능을 켠다. |
| -XX:+NumberOfGCLogFiles=<n> | 보관 가능한 최대 로그파일 개수를 설정한다.  |
| -XX:+GCLogFileSize=<size> | 순환 직전 각 파일의 최대 크기를 설정한다.  |

로그 순환 정책은 운영팀과 협의해서 합리적으로 수립해야 한다. 

**GC 로그 vs JMX**

VisualGC는 JVM의 힙 상태를 실시간으로 표시하는 툴이다. 실제로 자바 관리 확장 인터페이스(JMX) 를 통해 JVM 데이터를 수집한다. JMX는 GC에 영향을 주기 때문에 성능 엔지니어는 다음 사항을 숙지해야 한다.

- GC 로그 데이터는 실제로 가비지 수집 이벤트가 발생해서 쌓이지만, JMX는 데이터를 샘플링하여 얻는다.
- GC 로그 데이터는 캡처 영향도가 거의 없지만, JMX는 프록시 및 원격 메서드 호출 과정에서도 암묵적인 비용이 든다.
- GC 로그 데이터에는 자바 메모리 관리에 연관된 성능 데이터가 50가지 이상 있지만, JMX는 10가지도 안된다.

JMX는 성능 데이터 원천으로서 스트리밍된 데이터를 즉시 제공한다는 점에서는 GC 로그보다 낫지만, 요즘은 jClarity 센섬 같은 툴도 GC 로그 데이터를 스트리밍 하는 API를 제공하므로 별반 차이가 없다. 

JMX로 가져온 빈은 표준 빈이고 쉽게 액세스할 수 있다. 데이터 시각화 툴은 Visual VM 외에서 다양한 상용 제품들이 있다.

**JMX의 단점** 

JMX를 이용해 애플리케이션을 모니터링하는 클라이언트는 대부분 런타임을 샘플링하여 현재 상태를 업데이트 받는다.클라이언트는 데이터를 계속 넘겨받기 위해 런타임에 있는 JMX 빈을 폴링한다. 

문제는 가비지 수집이다. 수집기가 언제 실행될지 클라이언트는 알 도리가 없다. 다시 말해, 각 수집 사이클 전후의 메모리 상태 역시 알 수 없으므로 GC 데이터를 깊이 있게, 정확하게 분석할 수 없다. 

물론 JMX로 얻은 데이터가 분석할 만한 가치가 없는 건 아니지만, 장기적 추이를 파악하는 정도로 쓸 수 밖에 없다. 가비지 수집기를 정확하게 튜닝하려면 정보가 더 필요하다. 특히, 각 수집 전후의 힙 상태 정보가 대단히 중요하다. 

또 메모리압을 분석하는 활동이 매우 중요한데, JMX는 데이터를 수집하는 방식 때문에 이마저도 아예 불가능하다. 

그뿐만 아니라, JMXConnector 명세를 구현한 코드는 내부적으로 RMI에 의존하므로 RMI 기반 통신 채널의 고질적인 문제점에 취약하다.

- 방화벽에 포트를 열어야 하기 때문에 부차 소켓 접속이 맺어질 수 있다.
- 프록시 객체를 이용해 remove() 메서드 호출을 대행한다.
- 자바 종료화에 의존한다.

**GC 로그 데이터의 장점** 

최신 가비지 수집기는 수많은 부품이 한데 조립된, 엄청나게 복잡한 구현체이다. 수집기의 성능 역시 불가능하진 않지만 그만큼 예측하기가 힘들다. 이처럼 전체 구성 컴포넌트가 서로 맞물려 작동하면서 최종적 등장, 성능이 귀결되는 소프트웨어를 발현적이라고 한다. 상이한 압력이 각기 다른 컴포넌트에 서로 다른 방식으로 작용하므로 매우 유동적인 비용 모델이다. 

처음에 자바 GC를 개발한 사람들을 GC 로깅을 JVM 구현체 디버깅 용도로 추가했으나 시간이 흐르면서 애플리케이션에서 가비지 수집 프로세스 튜닝을 맡았던 사람들은, GC 튜닝의 복잡함을 감안하더라도 런타임에서 무슨 일이 발생했는지 정확히 파악하는 데 GC 로그가 아주 유용하다는 사실을 알게 되었다. 

GC 로그에 쌓인 기초 데이터는 특정 GC 이벤트와 연관 지을 수 있어서 모든 의미 있는 분석 작업 (어느 지점에서 수집 비용이 발생하는지, 어떻게 튜닝해야 긍정적인 결과를 얻을 수 있을 지 등)을 수행할 수 있다. 

### 로그 파싱 툴

GC 로그 메시지는 어떤 정해진 언어나 VM 명세 표준 포맷이 따로 없다. 로그에 무슨 메시지를 남길지는 핫스팟 GC 개발팀 마음이라 마이너 릴리즈 간에도 포맷이 조금씩 다르다.

단순한 로그 포맷을 파싱하는 건 어렵지 않지만, GC 로그 플래그가 하나둘 추가되면서 실제 출력되는 로그도 엄청나게 복잡해졌다. 

GC 설정을 변경해서 로그 출력 포맷이 달라지면 수동 GC 로그 파서를 쓰는 시스템에서 로깅이 끊어지는 사태가 곧잘 벌어진다. GC 로그를 자세히 조사해보면 하필 로그가 가장 필요한 때에 수동 파서가 변경된 로그 포맷을 처리하지 못한것을 알 수 있다.

**센섬**

센섬은 jClarity사가 제작한 상용 메모리 분석기이다. (단일 JVM에서 간단히 분석 가능한) 데스크톱 툴로 써도 되고 (여러 JVM을 대상으로 하는) 서비스 모니터링 용도로도 사용할 수 있다. 센섬은 최고의 GC 로그 파싱, 정보 추출, 자동 분석 기능을 제공하는 것이 목표이다. 

센섬 SaaS 모니터링 서비스를 이용하면 전체 클러스터 상태를 한눈에 볼 수 있다는 장점이 있다.

센섬 최신 버전이 지원하는 자동 분석 기능은 다음과 같다.

- 정확한 할당률
- 조기 승격
- 공격적인 할당
- 유저 이탈
- 메모리 누수 감지
- 힙 크기 조정 및 용량 계획
- VM에 대한 OS 간섭
- 크기를 잘못 잡은 메모리 풀

**GCViewer**

GCViewer는 GC 로그 파싱 및 그래프 출력 등 기본 기능을 갖춘 데스크톱 툴이다. 

GCViewer는 분석 기능은 없고 특정 GC 핫스팟 로그 포맷만 파싱할 수 있다.

GCViewer를 파싱 라이브러리로 쓰고 결과 데이터를 시각화 툴로 내보내는 방법도 있지만, 기존 오픈 소스 코드 베이스에 추가 개발을 해야하는 부담이 있다.

### GC 기본 튜닝

GC 튜닝 역시 다른 튜닝 기법처럼 전체 진단 과정의 일부여야 한다. 다음 사실을 기억하면 실무에서 GC 튜닝을 할 때 도움이 될 것이다.

1. GC가 성능 문제를 일으키는 근원이라고 확인하거나 그렇지 않다고 배제하는 행위는 저렴하다.
2. UAT에서 GC 플래그를 켜는 것도 저렴한 행위다.
3. 메모리 프로파일러, 실행 프로파일러를 설정하는 작업은 결코 저렴하지 않다.

엔지니어는 튜닝을 수행하면서 다음 네 가지 주요 인자를 면밀히 관찰/측정해야 한다.

- 할당
- 중간 민감도
- 처리율 추이
- 객체 수명

이 중에서 가장 중요한 요인은 할당이다.

다음은 힙 크기를 조정하는 기본 플래그이다.

| 플래그 | 작용 |
| --- | --- |
| -Xms<size> | 힙 메모리의 최소 크기를 설정한다 |
| -Xmx<size> | 힙 메모리의 최대 크기를 설정한다 |
| -XX:MaxPermSize=<size> | 펌젠 메모리의 최대 크기를 설정한다 |
| -XX:MaxMetaspaceSize=<size> | 메타스페이스 메모리의 최대 크기를 설정한다 |

MaxPermSize는 자바 7 이전에만 적용되는 레거시 플래그이다. 자바 8부터는 펌젠이 사라지고 메타스페이스로 교체됐다. 

튜닝 시 GC 플래그는 다음과 같이 추가한다.

- 한번에 한 플래그씩 추가한다.
- 각 플래그가 무슨 작용을 하는지 숙지해야 한다.
- 부수 효과를 일으키는 플래그 조합도 있음을 명심한다.

성능 문제를 일으키는 원인이 GC인지 아닌지 판단하는 방법은 먼저, vmstat 같은 툴로 고수준의 머신 지표를 체크하고 성능이 떨어진 시스템에 로그인해서 다음을 확인해야 한다.

- CPU 사용률이 100%에 가까운가?
- 대부분의 시간이(90% 이상) 유저 공간에서 소비되는가?
- GC 로그가 쌓이고 있다면 현재 GC가 실행 중이라는 증거다.

위 세 가지 조건이 다 만족한다면 GC가 성능 이슈를 일으키고 있을 가능성이 크고 철저한 조사와 튜닝이 필요하다. GC가 성능 문제의 원인임을 찾은 뒤에는 할당과 중간 시간 양상을 파악한 다음, GC를 튜닝하고 필요 시 메모리 프로파일러를 활용해야 한다.

**할당이란?**

할당률 분석은 튜닝 방법뿐만 아니라, 실제로 가비지 수집기를 튜닝하면 성능이 개선될지 여부를 판단하는 데 꼭 필요한 과정이다.

영 세대 수집 이벤트 데이터를 활용하면 할당된 데이터양, 단위 수집 시간을 계산할 수 있고, 일정 시간 동안의 평균 할당률을 산출할 수 있다. 

가비지 수집기 튜닝만으로 해결할 수 없는 성능 문제의 성능을 향상시키려면 애플리케이션 핵심부의 할당 로직을 제거하는 리팩터링을 수행하여 메모리 효율을 개선하는 방법 밖에 없다. 초기 할당 전략은 다음 네 가지 단순 영역에 집중하는 것이 좋다.

- 굳이 없어도 그만인, 사소한 객체 할당
- 박싱 비용
- 도메인 객체
- 엄청나게 많은 논JDK 프레임워크 객체

먼저 첫 번째 항목은, 불필요한 객체를 생성하는 부위를 찾아 그냥 제거하면 된다. 과도한 박싱도 그중 하나지만, 이밖에도 쓸데없이 객체를 생성하는 출처는 다양하다. 드물지만 도메인 객체가 메모리를 많이 차지하는 일도 있다. 주로 다음 타입이 문제다.

- char[] : 스트링을 구성하는 문자
- byte[] : 바이너리 데이터
- double[] : 계산 데이터
- 맵 엔트리
- Object[]
- 내부 자료 구조(methodOop, klassOop)

단순 힙 히스토그램을 그려보면 불필요한 도메인 객체가 히스토그램의 상위권을 점유하면서 과하게 생성되는 모습을 볼 수 있다. 이럴 때는 도메인 객체의 예상 데이터양을 재빨리 계산해 실제 측정된 데이터양과 비슷한 수준인지 확인한다.

스레드 로컬 할당 기법은 스레드마다 객체를 할당할 공간을 개별 발급하여 O(1) 할당을 달성한다.

TLAB은 스레드 당 크기가 동적 조정되며, 일반 객체는 남은 TLAB 공간에 할당된다. 여유 공간이 없으면 스레드는 VM에게 새 TLAB을 달라고 요청한 다음 재시도한다. 

객체가 너무 뚱뚱해서 빈 TLAB에 안 들어가면 VM은 TLAB 외부 영역에 위치한 에덴에 직접 객체를 할당 시도한다. 이것도 실패하면 영 GC를 수행하는 다음 단계로 넘어간다. 그래도 공간이 부족하면 최후의 방법으로 테뉴어드 영역에 객체를 직접 할당한다. 따라서 결국 덩치 큰 배열만 곧바로 테뉴어드에 할당될 가능성이 크다. 핫스팟은 TLAB 및 큰 객체의 조기 승격에 관한 튜닝 플래그를 제공한다. 

```
-XX:PretenureSizeThreshold=<n>
-XX:MinTLABSize=<n>
```

할당률은 테뉴어드로 승격되는 객체 수에 영향을 끼친다. 단명 자바 객체의 수명이 불변이라고 가정하면 할당률이 높을수록 영 GC 발생 주기는 짧아진다. 너무 자주 수집이 일어나면 단명 객체는 장례를 치를 시간도 없이 테뉴어드로 잘못 승격될 가능성이 크다. 즉, 할당이 폭주하면 조기 승격 문제가 불거질 것이다. JVM은 이런 일이 없도록 테뉴어드 승격 없이 엄청난 양의 생존 데이터를 담을 서바이버 공간을 동적 조정한다. 조기 승격 문제에는 다음 스위치가 요긴하게 쓰인다.

```
-XX:MaxTenuringThreshold=<n>
```

테뉴어드 영역으로 승격되기 전가지 객체가 통과해야 할 가비지 수집 횟수를 설정하는 것이다. 디폴트 값은 4회이고 1~15 사이의 한계치를 설정할 수 있다. 이 값을 바꿀 때는 다음 두 가지 상충되는 관심사를 잘 따져봐야 한다. 

- 한계치가 높을수록 진짜 장수한 객체를 더 많이 복사한다.
- 한계치가 너무 낮으면 단명 객체가 승격되어 테뉴어드에 메모리압을 가중시킨다.

**중단 시간이란?**

중단 시간 튜닝 시 유용한 휴리스틱은 다음과 같다.

- >1초 : 1초 이상 걸려도 괜찮다.
- 1초~100밀리초 : 100밀리초 이상 1초 이하 정도는 괜찮다.
- <100밀리초 : 100밀리초까지는 괜찮다.

중단 민감도를 애플리케이션 힙 크기와 대략 연관 지어보면 어떤 수집기가 가장 적합한지 가늠할 수 있다. 

**수집기 스레드와 GC 루트**

GC 루트 탐색 시간은 다음과 같은 요인의 영향을 받는다. 

- 애플리케이션 스레드 개수
- 코드 캐시에 쌓인 컴파일드 코드량
- 힙 크기

이 셋은 GC 루트 탐색에 큰 영향을 끼친다. 런타임 조건 및 적용 가능한 병렬화 정도에 따라서도 달라진다.

예를 들어 마킹 단계에서 매우 큰 Object[]를 발견했다고 하자. 탐색은 단일 스레드로 수행하므로 작업 훔쳐오기가 불가능하기 때문에 극단적으로는 이 단일 스레드의 탐색 시간이 전체 마킹 시간을 결정짓게 된다. 

객체 그래프가 복잡해질수록 이런 현상은 더욱 심해진다. 그래프 내부에 객체 체인이 길게 늘어지면서 마킹 시간도 점점 더 길어진다. 애플리케이션 스레드가 너무 많아도 스택 프레임을 더 많이 탐색해야 하고 세이프포인트에 도달하는 시간도 길어지는 등 GC 시간에 영향을 끼친다. 베어 메탈과 가상 환경에 존재하는 스레드 스케줄러도 압박한다. 

JNI 프레임과 JIT 컴파일드 코드용 캐시 등 다른 GC 루트 원천들도 있다.

### Parallel GC 튜닝

이 수집기는 가장 단순한 수집기라서 튜닝 역시 제일 쉽다. 이 수집기의 목표와 트레이드오프는 뚜렷하다.

- 풀 STW
- GC 처리율이 높고 계산 비용이 싸다.
- 부분 수집이 일어날 가능성은 없다.
- 중단 시간은 힙 크기에 비례하여 늘어난다.

이와 같은 특성들이 별문제가 안 되는 애플리케이션 특히, 힙이 4기가바이트 이하로 작은 경에서는 Parallel GC가 아주 효과적인 선택이다. 

과거에는 다음과 같은 크기 플래그를 적용해 다양한 메모리 풀의 상대적 크기를 조정했던 애플리케이션도 있다.

| 플래그 (옛 플래그) | 작용  |
| --- | --- |
| -XX:NewRario=<n> | 영 세대 / 전체 힙 비율 |
| -XX:SurvivorRatio=<n> | 서바이버 공간 / 영 세대 비율 |
| -XX:NewSize=<n> | 최소 영 세대 크기 |
| -XX:MaxNewSize=<n> | 최대 영 세대 크기 |
| -XX:MinHeapFreeRatio | 팽창을 막기 위한 GC 이후 최소 힙 여유 공간 비율(%) |
| -XX:MaxHeapFreeRatio | 수축을 막기 위한 GC 이후 최대 힙 여유 공간 비율(%) |

대부분의 최신 애플리케이션은 사람보다 프로그램이 크기를 알아서 잘 결정하기 때문에 이렇게 명시적으로 크기를 설정하는 일은 삼가는 게 좋다. 이런 스위치는 Parallel GC에서 어쩔 수 없는 경우, 최후의 수단으로만 사용한다. 

### CMS 튜닝

CMS는 튜닝이 까다롭기로 소문난 수집기이다. CMS로 최상의 성능을 얻는 과정에는 여러 가지 복잡성과 트레이드오프가 있다. 

CMS 처럼 중단 시간이 짧은 수집기는 정말로 STW 중단 시간을 단축시켜야 하는 유스케이스에 한해 어쩔 수 없을 때만 사용해야 한다. 그렇지 않으면 딱히 이렇다 할 성능 향상도 못 보고 튜닝하기 힘든 수집기를 사용하게 된다. “중단 시간은 나쁘다, 고로 동시 마킹 수집기가 좋다”는 단순 선입견이다.

CMS 플래그의 가짓수는 실로 방대해 안티패턴의 늪에 빠질 우려가 있다.

그럼에도 CMS 성능을 개선하기 위해 튜닝을 감행해야 하는 경우가 발생할 것이다. 먼저 처리율부터 보면 CMS 수집이 일어나면 기본적으로 코어 절반은 GC에 할당되므로 애플리케이션 처리율은 그만큼 반토막이 난다. 이때 한 가지 유용한 경험 법칙은 CMF 발생 직전의 수집기 상태를 살펴보는 것이다.

CMS 수집이 끝나자마자 곧바로 새 CMS 수집이 시작되는 백투백 수집 현상은 동시 수집기가 얼마 못 가 고장날 것이라는 신호다. 애플리케이션의 메모리 할당 속도가 회수 속도를 능가하면서 결국 CMF가 일어날 것이다.

백투백 현상이 일어나면 사실상 전체 애플리케이션 실행 처리율은 50%나 떨어진다. 성능 엔지니어는 튜닝할 때 이런 최악의 상황이 발생해도 괜찮은지 고민해보고, 괜찮지 않다면 호스트에 코어 수를 늘리는 해결 방안을 모색해야 한다.

CMS 수집 중 GC에 할당된 코어 수를 줄이는 방법도 있다. 물론 그만큼 수집 수행 CPU 시간이 줄어들고 부하 급증 시 애플리케이션의 회복력이 떨어지는 (결국 CMF에 더 취약해짐) 위험은 감수해야 한다. 동시 GC 스레드 개수는 다음 스위치로 조절할 수 있다.

```
-XX:ConGCThreads=<n>
```

디폴트 설정 상태에서 애플리케이션이 충분히 신속하게 메모리를 회수하지 못하는 경우에 gc 스레드 수를 줄이면 상황이 더 악화될 것이다. 

CMS에서 STW는 두 단계에서 발생한다.

- 초기 마킹 : GC 루트가 직접 가리키는 내부 노드를 마킹한다.
- 재마킹 : 카드 테이블을 이용해 조정 작업이 필요한 객체를 식별한다.

따라서 모든 애플리케이션 스레드는 CMS가 한번 일어날 때 마다 반드시 2회 멈추는데, 포인트에 예민한 저지연 애플리케이션에서는 중요한 영향을 미칠 수 있다.다음 두 플래그를 함께 적용하면 도움이 된다.

```
-XX:CMSInitiatingOccupancyFraction=<n>
-XX:+UseCMSInitiatingOccupancyOnly
```

CMSInitiatingOccupancyFractiondms CMS가 언제 수집을 시작할지 설정하는 플래그이다. CMS가 실행되면 영 수집을 통해 올드 영역으로 승격되는 객체들을 수용할 여유 공간이 필요하다.

UseCMSInitiatingOccupancyOnly 플래그를 함께 설정하면 초기 점유 공간을 동적 크기 조정하는 기능이 꺼진다. 이 플래그는 함부로 켜선 안된다. 실제로 여유 공간을 줄일 일은 거의 없다.

할당률이 심하게 튀는 CMS 애플리케이션이라면 여유 공간을 늘리고 능동적 크기 조정 기능을 끄는 전략을 구사할 것이다. CMS의 동시 GC를 더 자주 일으키는 대가를 치르더라도 CMF를 줄여보자는 것이다. 

**단편화로 인한 CMF**

이는 튜닝 분석에 필요한 데이터가 GC 로그에만 존재하는 다른 사례이다. CMS가 관리하는 프리 리스트 때문에 CMF가 발생할 수도 있는데, 프리 리스트 통계치를 바탕으로 언제 JVM에서 CMF가 발생할지 미리 알 수는 없을까?

다음 JVM 스위치를 추가하면

```
-XX:PrintFLSStatistics=1
```

GC 로그에 다음과 같은 몇몇 추가 정보가 표시된다.

```
Total Free Space: 40115394
(총 프리 공간)

Max Chunk Size: 38808526
(최대 청크 크기)

Number of Blocks: 1360
(블록 개수)

Av. Block Size: 29496
(평균 블록 크기)

Tree Height: 22
(트리 높이)
```

평균 블록 크기와 최대 청크 크기를 보니 메모리 청크의 크기 분포를 대략 짐작할 수 있다. 덩치 큰 라이브 객체를 테뉴어드로 옮기려고 하는데 그만한 크기의 청크가 바닥난 경우, GC 승격이 악화되어 결국 CMF로 이어질 것이다.

JVM은 다시 Parallel GC로 동라가 힙을 압착하고 프리 리스트를 병합하며 STW 중단은 길어질 것이다. 실시간으로 분석하면 이러한 시간이 긴 중단이 임박했음을 미리 할 수 있어 좋다. 

### G1 튜닝

엔드 유저가 최대 힙 크기와 최대 GC 중단 시간을 간단히 설정하면 나머지는 수집기가 알아서 처리하게 하는 것이 G1 튜닝의 최종 목표이지만, 아직 현실은 조금 동떨어져 있다.

CMS처럼 G1도 구성 옵션이 꽤 많지만, 그중에는 여전히 실험적이고 VM내부에서 잘 드러나지 않는 것들도 있다. 튜닝을 해서 뭔가 바꿔도 어떤 영향을 미칠지 알아차리기가 어려운 것이다. 그래도 이런 옵션을 지정해서 튜닝해야 할 경우 다음 스위치를 반드시 지정해야 한다.

```
-XX:+UnlockExperimentalVMOptions
```

특히 이 스위치는 -XX:G1NewSizePercent=<n>나 -XX:G1MaxNewSizePercent=<n>을 사용할 경우 꼭 필요하다.

G1 튜닝에서 가장 큰 문제는, 이 수집기가 처음 등장한 이후로 내부적으로 상당히 많은 변화를 겪었다는 것이다. 따라서 초창기 G1에 관한 글들은 지금과 맞지 않는 경우가 많아서 섣불리 민간 튜닝을 하면 심각한 문제가 발생할 수 있다.

G1은 자바 9부터 디폴트 수집기로 격상되기 때문에 성능 엔지니어는 G1 튜닝 문제도 함께 다루어야 한다. 

G1은 CMS와 다르게 할당률에 뒤처지지 않는 한 계속 조금씩 압착하므로 CMF가 일어날 가능성은 전혀 없다. 어떤 애플리케이션에서 할당률이 계속 높은 상태로 대부분 단명 객체가 생성되고 있다면 다음 튜닝을 고려해볼만 하다.

- 영 세대를 크게 설정한다.
- 테뉴어드 한계치를 최대 15정도로 늘려 잡는다.
- 애플리케이션에서 수용 가능한 최장 중단 시간 목표를 정한다.

### jHiccup

jHiccup은 JVM이 연속적으로 실행되지 못한 지점, 즉 ‘히컵(hiccup)’을 보여주는 계측 도구이다. 히컵을 일으키는 가장 흔한 원인은 GC STW 중단이지만, OS나 플랫폼 관련 문제 때문에 발생하기도 한다. 따라서 jHiccup은 GC 튜닝에도 좋지만 초저지연 작업을 할 때도 유용하다.

jHiccup은 자바 명령줄에서 -javaagent:jHiccup.jar를 지정해 자바 에이전트로 사용한다.