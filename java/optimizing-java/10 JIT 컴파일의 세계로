## JIT 컴파일의 세계로

### JITWatch란?

오픈소스 자바 FX 툴이다.

개발/데브옵스 담당자가 JITWatch를 이용하면, 애플리케이션 실행 중에 핫스팟이 바이트코드에 무슨 일은 했는지 이해하는 데 도움이 된다. 반드시 핫 패스에 있는 컴파일 대상 메서드를 분석 대상으로 삼아야 한다. 인터프리티드 메서드는 최적화 대상으로 적절치 않다.

JITWatch는 객관적인 비교에 필요한 측정값을 제공한다. ITWatch는 핫스팟 컴파일 상세 로그를 파싱/분석하여 결과를 자바FX GUI 형태로 보여준다.

따라서 애플리케이션 실행 시 다음 플래그를 추가해야 JITWatch가 동작한다.

```java
XX:+UnlockDiagnosticVMOptions 
```

```java
-XX:+TraceClassLoading 
```

```java
-XX:+LogCompilation
```

### 기본적인 JITWatch 뷰

JITWatch엔 실행시킨 프로그램에서 로그를 적재하는 일뿐만 아니라, JIT 작동을 시험해볼 수 있는 샌드박스(sendbox) 환경을 제공한다. 샌드박스를 이용하면 작은 프로그램을 신속히 프로토타이핑 하여 JVM이 어떤 JIT 결정을 내렸는지 확인할 수 있다. 또한 샌드박스 워크플로우를 이용하면 로그파일 대신, 자바/JVM을 지원하는 언어로 작성된 프로그램을 생성하거나 로드할 수 있다.

RUN 버튼ㅇ를 클릭하면 다음 작업이 수행된다.

1. 프로그램 바이트코드로 컴파일 한다.
2. JIT 로그를 켜놓고 JVM에서 프로그램을 실행한다.
3. 분석용 JIT 로그파일을 JITWatch에 로드한다.

샌드박스는 작은 변화가 일어났을 때 JVM의 최적화 기법 선택을 포착하여 피드백한다. 도한 샌드박스는 JIT 서브 시스템을 조정하는 VM 스위치를 시험해볼 수 있는 환경을 제공한다. 그러나 설정을 바꾸면 JVM 성능에 심각한 영향을 줄 수도 있으니 운영계에서는 권장하지 않는다.

풀 사이즈 애플리케이션에선 JVM이 단지 샌드박스 한 조각이 아닌, 훨씬 광범위한 코드를 대상으로 최적화를 조합할 수 있다는 점이 샌드박스가 일반 JVM 애플리케이션 실행과 다른 점이다. 

예를 들어, 인라이닝 메서드는 그 메서드를 호출한 코드 안에서 모두 욱여넣는 기법이다. 이렇게 인라이닝하면 그 전에는 불확실했던 추가 최적화를 최적화기가 검토해볼 수 있는 여지가 생긴다. 따라서 JIT 컴파일러는 단순 인라이닝만 수행하는 샌드박스에서 실행한 토이 애플리케이션과, 진짜 인라이닝을 수행하는 실제 애플리케이션에 있는 메서드를 전혀 다르게 취급할 것이다. 이런 이유 때문에 살무자는 샌드박스보다 더 정교한 애플리케이션 컴파일 뷰를 선호한다. 

다행히 JITWatch는 3단뷰라는 뷰를 메인으로 제공한다. 뷰를 보면 소스 코드가 바이트코드, 어셈블리 양쪽으로 어떻게 컴파일됐는지 알 수 있다.

자바 8 이전에는 프로파일링을 거친 컴파일드 메서드, 논프로파일드 메서드, 그리고 VM 자체 네이티브 코드를 하나의 코드 캐시 영역에 담았다. 자바 9부터는 분할 코드 캐시가 생겨 컴파일드 메서드, 논프로파일드 메서드, VM 자체 네이티브 코드를 별도 영역에 저장한다. 이 덕분에 단편화 및 스위퍼 시간을 단축하고 풀 컴파일드 코드의 지역성을 높일 수 있게 되었다. 

### 디버그 JVM과 hsdis

디버그 JVM은 운영 JVM 보다 더 상세한 디버깅 정보를 얻기 위해 제작한 가상 머신이다. 좀 더 심도 있는 튜닝을 얻을 수 있으나, 그만큼 성능 희생은 감수해야 한다. 

JIT 컴파일러가 생성한 역어셈블된 네이티브 코드를 보려면 hsdis 같은 역어셈블리 바이너리가 필요하다.

## JIT 컴파일 개요

핫스팟은 프로파일 기반 최적화(PGO)를 이용해 JIT 컴파일 여부를 판단한다. 내부적으로는 핫스팟이 실행 프로그램 정보를 메서드 데이터 객체(MDO)라는 구조체에 저장한다. 

MDO의 쓰임새는 파이트코드 인터프리터와 C1 컴파일러에서 JIT 컴파일러가 언제, 무슨 최적화를 할지 결정하는 데 필요한 정보를 기록하는 것이다. 어떤 메서드가 호출됐고, 어느 분기문으로 갈라졌는지, 또 호출부에서는 무슨 타입이었는지 등의 정보가 담겨있다.

프로파일링된 프로퍼티의 사용빈도를 카운터에 계속 기록하고 기렇게 기록한 값들은 프로파일링을 거치면서 차츰 사라진다. 이로써 컴파일 큐 맨 앞에 이르렀을 때도 아직 핫한 메서드만 컴파일된다. 

이렇게 프로파일링 데이커가 모이고 컴파일 결정을 내린 후엔 컴파일러별 세부 처리 절차로 넘어간다. 컴파일러는 컴파일할 코드 내부 표현형을 빌드 한다. 구체적인 표현형은 컴파일러(c1 or c2)에 따라 잘라진다.

핫스팟 JIT 컴파일러는 내부 표현형을 토대로 다양한 최적화 기법을 총동원한다. 이러한 최적화 기법은런타임 정보와 지원 여부에 따라 완전 달라질 수 있다.

- 인라이닝
- 루프 펼치기
- 탈출 분석
- 락 생략/확장
- 단일형 디스패치
- 인트린직
- 온-스택 치환

핫스팟의 C1, C2 컴파일러 역시 위 기법을 상이하게 조합하며 기본적으로 컴파일에 접근하는 철학 자체가 다르다. 

- C1은 추측성 최적화를 하지 않는다. 따라서 실행 성격이 어떨지 확실하지 않은 가정하에 최적화를 하지 않는다.
- C2는 공격적인 최적화기로 런타임 정보를 토대로 추정하여 최적화를 수행한다. 단순 추정이지만 덕분에 적잖은 성능 향상을 볼 수도 있다.

추측성 최적화를 하기 전에 가드(guard)라는 타당성 검사를 수행한다. 가드는 앞서 추정한 내용이 여전히 유효한지 최적화된 코드를 실행할 때마다 확인하다.

가드마저 실패하면 더 이상 컴파일드 코드는 안전하지 않으므로 제거해야 한다. 핫스팟은 혹여 부정확한 코드가 실행되는 불상사를 막기 위해 역최적화를 수행한다.

## 인라이닝

인라이닝은 호출된 메서드의 콘텐츠를 호출한 지점에 복사하는 기법이다. 메서드 호출 시 다음과 같은 오버헤드를 제거할 수 있다.

- 전달할 매개변수 세팅
- 호출할 메서드를 정확하게 룩업
- 새 호출 프레임에 맞는 런타임 자료 구조(지역 변수 및 평가 스택 등) 생성
- 새 메서드로 제어권 이송
- 호출부에 결과 반환 (결괏값이 읶는 경우)

인라이닝은 JIT 컴파일러가 제일 먼저 적용하는 최적화라서, 관문 최적화라고도 한다. 메서드 경계를 없애고 연관된 코드를 한데 모아 놓기 때문이다.

인라이닝 최적화 덕분에 개발자는 재사용 가능한 코드를 작성할 수 있고, 무엇보다 손수 마이크로 최적화를 할 필요가 없다. 핫스팟은 자동으로 통계치를 분석해서 관련된 코드를 어느 시점에 하나로 모을지 결정한다. 그래서 인라이닝은 다른 최적화 범위를 확장시키는 역할을 한다.

- 탈출 분석, DCE(dead code elimination, 죽은 코드 제거), 루프 펼치기, 락 생략

### 인라이닝 제한

VM 차원에서 인라이닝 서브시스템에 제한을 걸어야 할 경우가 있다. 해당 경우는 다음과 같다. 

- JIT 컴파일러가 메서드를 최적화하는 데 소비하는 시간
- 생성된 네이티브 코드 크기 (즉 코드 캐시 메모리 사용량)

제약 조건이 하나도 없다면 아주 깊은 호출 체인까지 인라이닝할 것이고 결국 코드 캐시를 거대한 네이티브 메서드로 가득 채워 코드 캐시 공간이 줄어든다. JIT 컴파일이 값비싼 리소스라는 일반 원칙은 여기서도 적용된다. 

핫스팟은 다음 항목으로 메서드의 인라이닝 여부를 결정한다.

- 인라이닝할 메서드의 바이트코드 크기
- 현재 호출 체인에서 인라이닝할 메서드 깊이
- 메서드를 컴파일한 버전이 코드 캐시에서 차지하는 공간

### 인라이닝 서브시스템 튜닝

다음은 인라이닝 서브시스템의 작동 방식을 제어하는 기본적인 JVM 스위치들이다. 

| 스위치 | 디폴트(JDK 8, Linux x86_64) | 설명 |
| --- | --- | --- |
| -XX:MaxInlineSize= | 35바이트의 바이트코드 | 메서드를 이 크기 이하로 인라이닝 |
| -XX:FreeqInlineSize= | 325바이트의 바이트코드 | 핫 메서드를 이 크기 이하로 인라이닝 |
| -XX:InlineSmallCode= | 1000바이트의 네이티브 코드(단계 없음), 2000바이트의 네이티ㅡㅂ 코드(단계 있음) | 코드 캐시에 이 수치보다 더 많은 공간을 차지한 최종 단계 컴파일이 존재하는 경우 인라이닝하지 않는다. |
| -XX:MaxInlineLevel= | 9 | 이 수준보다 깊은 호출 프레임을 인라이닝하지 않는다. |

중요 메서드가 인라이닝되지 않는 경우(가령 인라이닝 최대 허용 크기를 살짝 초과) 환경에 따라 이런 메서드까지 인라이닝되도록 JVM 매개변수를 조정할 수도 있다. 매개변수를 바꿔가며 튜닝할 땐 반드시 측정 데이터를 근거로 삼아야 한다.

## 루프 펼치기

루프 내부의 메서드 호출을 전부 인라이닝하면, 컴파일러는 루프를 한번 순회할 때마다 비용이 얼마나 드는지, 반복 실행되는 코드는 크기가 얼마나 되는지 더 분명해진다.

백 브랜치 (한 번 순회를 마치고 루프문 처음으로 돌아가는 것)가 일어나면 그때마다 CPU는 유입된 명령어 파이프라인을 덤프하기 때문에 성능상 좋지 않다. 보통 루프 바디가 짧을수록 백 브랜치 비용이 상대적으로 높기 때문에 핫스팟은 다음 기준에 따라 루프 펼치기 여부를 결정한다.

- 루프 카운터 변수 유형 (대부분 객체 아닌 int, long형을 사용)
- 루프 보폭(한 번 순회할 때마다 루프 카운터 값이 얼마나 바뀌는지)
- 루프 내부 탈출 지점 개수(return 또는 break)

배열에서 데이터를 차례대로 가져와 합계를 구하는 메서드가 있다고 하자. 어셈블리어로는 이러한 액세스 패턴을 [base, index, offset] 조합으로 나타낼 수 있다.

- base 레지스터 : 배열 데이터의 시작 주소
- index 레지스터 : 루프 카운터 (자료형 크기만큼 곱한다)
- offset : 주소 오프셋

long[] 형 배열을 순회하는 루프에서 어떤 조건일 때 루프가 펼쳐지는지 알아보자. 루프를 돌며 배열 원소에 액세스 할 때 핫스팟은 루프를 세 구역으로 나누어 배열 겨예 검사를 제거한다.

| 루프 구역 | 경계 검사? | 설명 |
| --- | --- | --- |
| 사전 루프 | 예 | 초기 순회는 경계 검사를 한다. |
| 메인 루프 |  아니오 | 루프 보폭을 이용해 경계 검사를 안 해도 순회 가능한 최대 횟수를 계산한다. |
| 사후 루프 |  예 |  나머지 순회는 경계 검사를 한다.  |

다음과 같은 루프로 순회할 배열을 생성하는 코드가 있다.

```java
private static final int MAX = 1_000_000;

private long[] data = new long[MAX];

private void createData() {
	java.util.Random random = new java.util.Random();

	for (int  i = 0; i < MAX; i++) {
			data[i] = random.nextLong();
	}
}
```

이 배열을 int형 카운터와 long 형 카운터로 순회하면 int 형 카운터 루프의 처리량이 64% 더 높다. 어셈블리 수준까지 타고 내려가보면 long 형 카운터를 쓸 경우 루프 바디가 펼쳐지지 않고 루프 안에 세이프포인트 폴이 박힌다. JIT 컴파일러는 컴파일된 코드가 너무 오랫동안 세이프포인트 플래그 체크 없이 실행되는 일이 없도록 이렇게 세이프 포인트 검사 코드를 삽입한다.  증분값이 컴파일 타임에 일정한 상수 대신 변수로 저장되는, 즉 루프 보폭이 가변적인 경우 마이크로벤치마킹을 해보면 루프가 펼쳐지지 않고 매번 백 브랜치가 일어나기 직전에 세이프포인트 체크 코드가 삽입된다. 

### 루프 펼치기 정리

핫스팟은 다음과 같은 다양한 최적화 기법으로 루프 펼치기를 한다.

- 카운터가 int, short, cha형일 경우 루프를 최적화
- 루프 바디를 펼치고 세이프포인트 폴을 제거
- 루프를 펼치면 백 브랜치 횟수가 줄고 그만큼 분기 예측 비용도 덜하다.
- 세이프포인트 폴을 제거하면 순회할 때마다 하는 일이 줄어든다.

## 탈출 분석

핫스팟은 어떤 메서드가 내부에서 수행한 작업을 그 메서드 경계 밖에서도 볼 수 있는지, 또는 부수 효과를 유발하지 않는지 판별한다. 이러한 기법을 탈출 분석이라고 하며, 메서드 내부에서 할당된 객체를 메서드 범위 밖에서 바라볼 수 있는지 알아보는 용도로 쓰인다. 

탈출 분석 최적화는 반드시 인라이닝 수행 이후 시도한다. 인라이닝을 해서 호출부에 피호출부 메서드를 복사하면 호출부에 메서드 인수로 전달된 객체는 더 이상 탈출 객체로 표시되지 않기 때문이다.

핫스팟은 탈출 분석 단계 도중  잠재적으로 탈출한 객체를 세 유형으로 분류한다.

- NoEscape = 1 - 객체가 메서드/스레드를 탈출하지 않고 호출 인수로 전달되지 않으며 스칼라로 대체 가능하다.
- ArgEscape = 2 - 객체가 메서드/스레드를 탈출하진 않지만 호출 인수로 전달되거나 레퍼런스로 참조되며 호출 도중에는 탈출하지 않는다.
- GlobalEscape = 3 - 객체가 메서드/스레드를 탈출한다.

### 힙 할당 제거

빡빡한 루프 안에서 객체를 새로 만들면 그만큼 메모리 할당 서브시스템을 압박하게 되고,  단명 객체가 끊임없이 양산되면 이를 정리할 마이너 GC가 자주 발생할 것이다. 할당률이 너무 높아 영 세대가 꽉 차면 조기 승격이 될 가능성도 있다. 이정도 상황에 이르면 풀 GC 이벤트를 발동해서 정리해야 한다. 

핫스팟의 탈출 분석 최적화는 개발자가 객체 할당률을 신경 쓰지 않고도 자바 코드를 자연스레 작성할 수 있도록 설계되었다. 할당된 객체가 메서드를 탈출하지 않는다 할당된 객체가 메서드를 탈출하지 않는다고 판단되면 (NoEscape로 분류됨) VM은 스칼라 치환 최적화이라는 최적화를 적용해 객체 필드를 마치 처음부터 객체 필드가 아닌 지역 변수였던 것 처럼 스칼라 값으로 바꾼다. 그 다음 레지스터 할당기라는 핫스팟 컴포넌트에 의해 CPU 레지스터 속으로 배치된다.

탈출 분석의 목표는 힐 할당을 박을 수 있는지 추론하는 것이다. 만약 그럴 수 있다면, 객체는 스택에 자동 할당되고 GC 압박을 조금이나마 덜 수 있다.

다음 코드에서는 MyObj 인스턴스는 NoEscape로 분류된다.

```
public long noEscape() {
    long sum = 0;
    for (int i = 0; i < 1_000_000; i++) {
        MyObj foo = new MyObj(i);
        sum += foo.bar();
    }
    return sum;
}
```

다음 코드에서는 MyObj 인스턴스는 extBar() 의 인수로 전달되므로 ArgEscape로 분류된다.

```
public long argEscape() {
    long sum = 0;
    for (int i = 0; i < 1_000_000; i++) {
        MyObj foo = new MyObj(i);
        sum += extBar(foo);
    }
    return sum;
}
```

탈출 분석 직전 extBar()가 루프 바디 안으로 인라이닝되면 다시 NoEscape로 분류되어 힙 할당을 막을 수 있다.

### 락과 탈출 분석

핫스팟은 탈출 분석과 관련 기법으로 락 성능도 최적화한다. 단, 이 최적화는 synchronized를 사용한 인스린직 락에만 해당되며 java.util.concurrent 패키지의 락에는 적용되지 않는다.

락 최적화 핵심은 다음과 같다. 

- 비탈출 객체에 있는 락은 제거한다. (락 생략)
- 같은 락을 공유한, 락이 걸린 연속된 영역은 병합한다. (락 확장)
- 락을 해제하지 않고 같은 락을 반복 획득한 블록을 찾는다. (중첩 락)

### 탈출 분석의 한계

CPU 레지스터나 스택 공간은 상대적으로 희소한 리소스이다. 또 기본적으로 원소가 64개 이상읜 배열은 핫스팟에서 탈출 분석 혜택을 볼 수 없다. 이 개수 제한은 다음과 같은 스위치로 조정할 수 있다.

```java
XX:EliminateAllocationArraySizeLimit=<n>
```

핫스팟은 부분 탈출 분석을 지원하지 않는다. 객체가 어느 분기점에서건 힙에 객체를 할당하지 않는 최적화는 적용되지 않는다.  즉, 메서드 범위를 탈출하면 탈출 분석 최적화가 적용되지 않는다.

다음 코드는 조건에 따라 둘 중 하나로 분기하므로 mightEscape 객체가 메서드를 탈출할 경우 반드시 ArgEscape로 분류된다. 결국 객체 할당률과 GC압을 가중시키게 될 것이다. 

```
for (int i = 0; i < 100_000_000; i++) {
    Object mightEscape = new Object(i)
    if (condition) {
        result += inlineableMethod(mightEscape);
    } else {
        result += tooBigToInline(mightEscape);
    }
}
```

다음 코드처럼 비탈출 분기 조건 안에 객체 할당을 묶어둘 수 있다면 탈출 분석 덕을 볼 수 있다.

```
for (int i = 0; i < 100_000_000; i++) {
    if (condition) {
        Object mightEscape = new Object(i)
        result += inlineableMethod(mightEscape);
    } else {
        Object mightEscape = new Object(i)
        result += tooBigToInline(mightEscape);
    }
}
```

## 단형성 디스패치

핫스팟 C2 컴파일러가 수행하는  추측성 최적화는 대부분 경험적 연구 결과를 토대로 한다. 단형성 디스패치 기법도 그런 부류 중 하다이다. 아래의 경험적 사실을 기반으로 하는 추측성 최적화 기법이다.

어떤 객체의 메서드를 호출할 때 그 메서드를 최초 호출한 객체의 런타임 타입을 알아내면 이후 호출도 동일 타입일 가능성이 크다. 이 추측성 가정이 옳다면 해당 호출부의 메서드 호출을 최적화할 수 있다. 항상 타입이 같다면 일단 호출 대상을 계산해서 invokevirtual 명령어를 퀵 타입 테스트 후 컴파일드 메서드 바디로 분기하는 코드로 치환하면 된다. 다시 말해, klass 포인터 및 vtable을 통해 가상 룩업을 하고 에둘러 메서드를 참조하는 일은 한 번만 하면 된다.

매번 같은 인스턴스를 반환하다 갑자기 다른 인스턴스를 반환되면, 즉 호출부의 런타임 타입이 변경되면 단형성 디스패치를 사용하다가 호출부의 런타임 타입이 변경되면 핫스팟은 최적화를 단념하고 호출부를  풀 가상 디스패치를 이용하는 방식으로 되돌린다.

단형성 호출을 보호하는 가드는 그냥 klass 워드와 동등하며 아주 단순하게 작동한다. 매번 명령어를 호출할 때마다 사전에 부정확한 코드가 실행되지 않게 체크한다. 

일반 애플리케이션에서는 절대 다수가 단형적 호출이다. 핫스팟은 자주 쓰이지는 않지만 이형성 디스패치라는 최적화도 지원한다. 그래서 서로 다른 두 타입을 단형성 디스패치와 같은 방법으로, 호출부마다 상이한 두 klass 워드를 캐시해서 처리한다. 

단형도, 이형도 아닌 호출부를 다형성이라고 한다. 극히 소수의 관측된 타입을 지닌 다형성 호출부를 찾아내면 성능 향상을 도모할 묘기를 부릴 수 있다. 원래 호출부에서 instanceof 체크를 하며 타입을 하나씩 벗겨내어 두 가지 구체 타입을 바라보는 이형성 호출부만 남겨두는 것이다. 

## 인트린직

인트린직은 JIT 서브시스템이 동적 생성하기 이전에 JVM이 이미 알고 있는 고도로 튜닝된 네이티브 메서드 구현체를 가리키는 용어이다. 주로 OS나 CPU 아키텍처 특정 기능을 응용하는 성능이 필수적인 코어 메서드에 쓰인다. 따라서 플릿폼에 따라 지원되는 것도 있고 안 되는 것도 있다.

JVM은 가동 직후 런타임에 자신을 실행한 하드웨어의 CPU를 살펴보고 사용 가능한 기능을 목록화한다. 즉 어떤 식으로 최적화할지 코드 컴파일 타임에 결정할 필요 없이 런타임까지 미룰 수 있다.

인트린직은 C1/C2 JIT 컴파일러 및 인터프리터에도 구현 가능하다.

다음은 많이 쓰이는 인트린직이다. 

| 메서드 | 설명 |
| --- | --- |
| java.lang.System.arraycopy() | CPU의 백터 지원 기능으로 배열을 빨리 복사한다 |
| java.lang.System.currentTimeMillis() | 대부분 OS가 제공하는 구현체가 빠르다 |
| java.lang.Math.min() | 일부 CPU에서 분기 없이 연산 가능하다 |
| 기타 java.lang.Math 메서드 | 일부 CPU에서 직접 명령어를 지원한다 |
| 암호화 함수 (ex. AES) | 하드웨어로 가속하면 성능이 매우 좋아진다 |

자바 9부터 메서드 앞에 @HotSpotIntrinsicCandidate 애너테이션을 붙여 인트린직을 사용할 수 있음을 나타낸다.

새 인트린직을 추가할 때에는 복잡도가 증가하는 것과 유용하게 잘 쓰는 것 사이에서 저울질을 해봐야 한다. 가령 자연수 N 까지의 합계를 구하는 것처럼 기본적인 산술 연산을 수행하는 인트린직이 있다고 하자. 기존 자바 코드로는 O(N) 작업을 해야 계산할 수 있지만, 사실 단순 공식 하나로 O(1) 시간만에 계산할 수 있다. 

그럼 소요 시간이 일정한 합계 계산 인트린직을 구현해야 할까? 이 질문에 대한 답은 전체 클래스 중 이렇게 합계를 계산해야 하는 것이 얼마나 많은 지에 따라 다르다. 방금 전 예시한 것처럼 단순 합계를 구하는 인트린직이라면 구현해도 활용도가 낮고 JVM에 복잡도를 가중시킬 뿐 큰 가치는 없을 듯 하다. 

인트린직은 정말 자주 쓰이는 작업에 한에서만 성능에 큰 영향을 미칠 수 있다. 

## 온-스택 치환

컴파일할 정도로 호출 빈도가 높지 않지만 메서드 내부에 핫 루프가 포함된 경우가 있다. 자바의 main() 메서드가 그렇다. 핫스팟은 이런 코드를 온-스택 치환(OSR)을 이용해 최적화한다. 인터프리터가 루프 백 브랜치 횟수를 세어보고 특정 한계치를 초과하면 루프를 컴파일한 후 치환해서 실행한다.

컴파일러는 컴파일 이전의 흐름과 변화가 컴파일 이후에도 반영되도록 보장해야 한다. 또 컴파일드 루프를 벗어난 후 실행을 재개하는 지점에서 모든 상태 변화가 가시적이어야 한다. 

## 세이프포인트 복습

세이프포인트에 걸리는 조건은 GC STW 이벤트뿐만 아니라 다음 경우에도 전체 스레드가 세이프포인트에 걸린다.

- 메서드를 역최적화
- 힙 덤프를 생성
- 바이어스 락을 취소
- 클래스를 재정의 (가령, 인스트루먼테이션 용도로)

컴파일드 코드에서 세이프포인트 체크 발급은 JIT 컴파일러가 담당하며, 핫스팟에서는 다음 지점에 세이프포인트 체크 코드를 넣은다.

- 루프 백 브랜치 시점
- 메서드 반환 지점

따라서 스레드가 세이프포인트에 도달하려면 시간이 소요될 수 있다. 가령 메서드를 전혀 호출하지 않고 많은 산술 연산 코드가 포함된 루프를 실행할 경우 루프가 펼쳐져 있으면 더 시간이 걸릴 것이다.

JIT 컴파일러는 프로그램 로직이 바뀌지 않는 한도 내에서 온갖 추측성 명령어, 비순차적 명령어를 한껏 만들어 낸다. VM이 세이프포인트를 걸면 컴파일드 코드는 그 지점의 프로그램 상태와 일치할 것이다. 디버거는 바로 이런 원리로 작동한다. 

컴파일러는 세이프포인트를 폴링하며 체크하는 비용을 감수하느냐,  이미 세이프포인트에 닿은 스레드가 다른 스레드도 세이프포인트에 모두 닿을 때까지 대기하는 긴 시간 (TTSP)을 회피하느냐 사이에서 고민할 것이다. 

## 코어 라이브러리 메서드

### 인라이닝 하기 적합한 메서드 크기 상한

인라이닝을 할지 말지는 메서드의 바이트코드 크기로 결정되므로 클래스 파일을 정적 분석하면 인라이닝 하기에 큰 메서드를 솎아낼 수 있다.

JarScan이라는 오픈 소스 툴은 클래스 폴더 또는 JAR 파일 내부에서 바이트코드 크기가 주어진 한계치 이상인 메서드를 모두 찾을 수 있다.

**도메인에 특정한 메서드로 성능 개선**

ASCII 캐릭터만 입력 받는다면 toUpperCase()를 도메인에 특정한 메서드로 만들어 바이트코드 크기를 인라이닝 한계치 이하로 줄일 수 있다. 

ASCII 전용 구현체를 만들어 컴파일하면 바이트코드가 69바이트밖에 안 된다. 그리고 ASCII 전용 버전이 코어 라이브러리보다 약 2.4배 초당 처리 건수가 많다.

**메서드를 작게 유지하면 좋은 점**

메서드를 작게 만들면 인라이닝 가짓수가 늘어난다. 런타임 데이터가 다양해질수록 여러 상이한 경로를 거치며 코드가 ‘핫’하게 될 가능성이 있다.

메서드를 작게 유지하면 다양한 인라이닝 트리를 구축해 핫 경로를 더욱 최적화할 여지가 생긴다. 메서드가 커지면 인라이닝 한계치를 초과해 최적화 안 된 경로가 남게 된다. 

### 컴파일하기 적합한 메서드 크기 상한

핫스팟에는 컴파일되지 않는 메서드 크기 한계치(8000 바이트)가 있다. 운영계 JVM에서 이 수치를 바꿀 순 없지만, 디버그 JVM에서는 다은과 같은 스위치로 컴파일 가능한 메서드 바이트코드의 최대 크기를 설정할 수 있다.

```java
-XX:HugeMethodLimit=<n>
```

비대한 코어 라이브러리 메서드는 핫 코드에서 발견된 가능성은 크지 않다. 대부분 UI 서브시스템을 초기화하거나 화폐, 국가, 로케일명 목록 등의 리소스를 제공하는 부류의 메서드이다. 

자동 생성된 코드에서 거대한 메서드가 발견되는 사례가 많다. 가령 쿼리 자동 생성 소프트웨어에서 쿼리가 점점 복잡해져 핫스팟 한계치에 다다를 것 같으면 JarScan으로 한 번 메서드 크기를 확인해보는 게 좋다.