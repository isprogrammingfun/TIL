## 고성능 로깅 및 메시징

자바 플랫폼의 기본 철학은 저수준의 세부 관심사에서 개발자를 해방시키는 것이다. 그 결과 도입된 자동 메모리 관리 기능은 개발자 생산성을 끌어올린 주역이 되었다. 

그러나 가비지 수집을 비롯해 JVM에 추상화된 고수준의 관리 기능은 성능이 주 관심사인 상황에서 그 결과를 예측하기 어렵다. 지연에 매우 민감한 애플리케이션에서는 당연히 이러한 불확정성을 최소화해야 한다. 

로깅은 모든 자바 개발자가 당연히 관심을 가져야 할 문제이다. 실제로 관리/운영이 잘 되는 자바 시스템은 대부분 상당량의 로그 메시지를 지니고 있다. 

메시징 시스템은 최근 수년간 가장 성공적으로 정착한 아키텍처 패턴이다. 보통 저지연 시스템의 최전방에 위치해서 초 단위로 처리된 메시지 개수로 성능을 측정한다. 시스템이 처리 가능한 메시지 개수는 종종 경쟁력 확보 차원에서 중요하다. 

### 로깅

다음은 제품급 로깅 시스템 선정 시 바람직하지 않은 안티패턴이다. 

- 10년짜리 로거 - 누군가 이미 설정해 놓은 로거를 계속 다시 사용
- 프로젝트 전체 로거 - 누군가 프로젝트 각 파트마다 따로 로거를 재구성하지 않아도 되게끔 로거를 감싸 놓음
- 전사 로거 - 누군가 전사적으로 사용 가능한 로거를 만들어 놓음

업무적으로 그리 중요하지 않다 생각하는 로깅 시스템을 유지 보수할 때 전체 조직에 고루 영향을 미치는 기술 부채로 이어지기도 한다. 

사실 로거는 그다지 흥미로운 주제는 아니라 그 선정 과정에서 앞서 열거한 안티패턴을 답습하는 경우가 많다. 그러나 로거는 실제로 모든 애플리케이션에 가장 중요한 부분이다.

대부분 고성능 환경에선 처리 정확도와 리포팅(보고)이 속도만큼이나 중요하다. 신속하지만 부정확하게 처리하는 건 아무 의미 없고, 감사 요건상 정확하게 리프팅 처리가 되어야 할 때도 있다. 로그는 운영팀이 이슈의 단서를 찾는데 도움이 되고 사후 조사를 할 수 있을 정도로 충분한 로그를 남겨야 한다. 시스템에 있는 여느 컴포넌트처럼 로거를 단순히 비용으로 취급해선 곤란하다. 프로젝트를 할 때 신중하게 잘 살펴서 포함시켜야 할 주요 기능이다. 

**로깅 벤치마크**

다음은 가장 많이 쓰는 세 로거 (Logback, Log4j, java.util.loggin)의 성능을 비교하는 벤치마크이다. 

- 로깅 없음
    
    로깅 없음은 현재 로거가 켜져 있고 어떤 한계치 이하로 메시지가 로깅되고 있는 상태에서 무동작 로그의 비용을 측정하는 벤치마크 테스트이다. 즉 실험 결과를 비교할 대조군에 해당한다.
    
- Logback 포맷
    
    ```
    14:18:17.635 [Name of Thread] INFO c.e.NameOfLogger - Log message
    ```
    
    Logback 1.2.1 버전을 사용한 벤치마크이다.
    
- java.util.logging 포맷
    
    ```
    Feb 08, 2017 2:09:19 PM com.example.NameOfLogger nameOfMethod
    INFO: Log message
    ```
    
- Log4j 포맷
    
    ```
    2017-02-08 14:16:29,651 [Name Of Thread] INFO com.example.NameOfLogger - message
    ```
    
    Log4j 2.7 버전을 사용한 벤치마크이다. 
    
- 측정
    - 세 로거를 비교하기 위해 아이맥과 AWS EC2 t2.xlarge인스턴스에서 벤치마크를 했을 때, 아이맥에서 java.util.logging 포맷을 사용한 자바 유틸 로거가 가장 성능이 나쁘고, Logback이 전반적으로 성능이 가장 우수하고 로깅 포맷이 Log4j 일 때 가장 좋다.
    - 전체 실행 속도는 AWS가 빠른 편이다.
- 로거 결과
    - 어떤 로깅 포맷, 어떤 로깅 프레임워크를 사용했는지, 그리고 설정값에 따라 결과는 다양하다.
    - 실행 시간 측면에선 대체로 Logback 성능이 가장 좋고 자바 유틸 로거가 제일 나빴다.
    - Log4j 포맷은 일반적으로 가장 일관된 결과를 보였다.
    - 실제 시스템에선, 특히 결과 수치가 엇비슷할 경우, 운영 장비에서 직접 실행 성능을 테스트 해보는 것이 좋다.
    - 마이크로벤치마크는 문제를 작은 통 안에 넣고 보기 때문에 시스템 전체에 미치는 영향도는 가려지는 위험성이 있기에 다른 예기치 않은 방식으로 애플리케이션에 영향을 미칠 수 있는 마이크로벤치마크 결과를 토대로 결론을 내릴 가능성이 있다.
    - 로깅 프레임워크가 생성하는 엄청난 양의 가비지도 잘 따져봐야 한다. 로깅하는 데 소비한 CPU 시간만큼 핵심 업무를 병렬 처리할 기회를 잃어버리기 때문이다. 로깅 라이브러리의 설계와 작동 원리 역시 직선적인 마이크로벤치마크 실행 결과만큼 중요하다.

### 성능에 영향이 적은 로거 설계하기

로깅은 필수 컴포넌트지만 저지연 애플리케이션에서 로거가 성능 병목을 초래해서는 안 된다.

Log4j 2.6 버전은 정상 상태의 가비지-프리한 로거로 해결하는 것을 목표로 출시되었다. Log4j 2.6에서 성능이 향상된 비결은, 각 로그 메시지마다 임시 객체를 생성했던 로직을 객체를 재사용하는 방향으로 수정한 것이다.  이는 바로 객체 풀 패턴을 실천한 전형적인 사례이다. Log4j 2.6는 `ThreadLocal` 필드를 이용해 스트링 → 바이트 변환 시 버퍼를 재사용하는 식으로 객체를 재사용한다.

`ThreadLocal` 객체는 웹 컨테이너에서 문제가 될 수 있다. 특히, 웹 애플리케이션과 웹 컨테이너 사이에 로드/언로드하는 시점이 문제다. Log4j 2.6은 웹 컨테이너 내부에서 실행 시 `ThreadLocal`을 안쓰지만, 성능 향상을 도모하고자 일부 공유된/캐시된 구조체를 사용한다. 

Log4j는 임시 배열을 생성해 로그문에 전달되는 매개변수를 담고 가변인수를 사용해 할당 횟수를 줄인다. Log4j를 SLF4J로 감싸면 퍼사드가 매개변수를 2개만 지원하기 때문에, 가비지-프리한 방식을 응용하거나 Log4j2 라이브러리를 직접 사용해서 코드 베이스를 리팩터링할 필요가 없다.

### 리얼 로직 라이브러리를 이용해 지연 줄이기

리얼 로직은 저수준 세부의 이해가 고성능 설계에 영향을 미친다는 기계 공감 접근 방식을 주장한 마틴 톰슨이 설립한 영국 회사이다. 디스럽터 패턴은 그가 자바 세계에 기여한 가장 유명한 작픔이다. 

다음은 다양한 유명 오픈 소스 프로젝트이다.

- 아그로나: 자바용 고성능 자료 구조 및 유틸 메서드
- 단순 바이너리 인코딩(SBE): 고성능 메시지 코덱
- 에어론: 효율/안정적 UDP 유니캐스트, UDP 멀티캐스트, IPC 메시지 전송
- 아티오: 탄력적인 고성능 FIX 게이트웨이

**아그로나**

저지연 애플리케이션 전용 구성 요소를 담은 라이브러리이다. 아그로나는 진정한 저지연 애플리케이션용 라이브러리 세트를 제공한다. 표준 라이브러리만으로 유스케이스 충족이 어렵다면 아그로나 라이브러리를 검토해보는 수순이 합리적이다. 

1. **버퍼**

자바엔 다이렉트/논다이렉트 버퍼를 추상화한 `ByteBuffer` 클래스가 있다. 다이렉트 버퍼는 자바 힙 밖에 있기 때문에 논 다이렉트버퍼보다 할당/해제율은 낮은 편이다. 다이렉트 버퍼의 장점은 중간 단계의 매핑 없이 직접 구조체에 명령어를 실행하는 것이다. 

`ByteBuffer` 는 일반화한 유스케이스가 가장 큰 문제로, 버퍼 타입별로 최적화를 적용할 수 없다. 또한 `ByteBuffer`는 아토믹 연산을 지원하지 않으므로 생산자/소비자 방식의 버퍼를 구축할 때 제약이 따른다. 또 `ByteBuffer` 를 사용하려면 매번 다른 구조체를 감쌀 때마다 하부 버퍼를 새로 할당해야 한다.

아그로나는 복사를 지양하며 저마다 독특한 특성을 지닌 네 가지 버퍼를 지원한다. 따라서 각 버퍼 객체마다 있음직한 상호작ㅇㅅㅇ을 정의/제어할 수 있다. 

- `DirectBuffer` 인터페이스: 버퍼에서 읽기만 가능하며 최상위 계층에 위치한다.
- `MutableDirectBuffer` 인터페이스: `DirectBuffer`를 상속하며 버퍼에 쓰기도 가능하다.
- `AtomicBuffer` 인터페이스: `MutableDirectBuffer`를 상속하며 메모리 엑세스 순서까지 보장
- `UnsafeBuffer` 클래스: `Unsafe`를 이용해 AtomicBuffer를 구현한 클래스이다.

아그로나 구현 코드는 매우 저수준이고 Unsafe를 광범위하게 사용한다. 그렇다고 아그로나가 임시방편인 것은 아니다. 오히려 반대이다. 이런 코드는 반 최적화나 다름없는 과거 JVM 내부에 적용된 낡은 최적화를 우회하기 위해서라도 꼭 필요하다. 

아그로나 버퍼를 통해 다양한 get 메서드로 하부 데이터를 가져올 수 있다. 버퍼를 래핑하더라도 개발자는 데이터 인덱스가 어느 지점에 있는지 알고 있어야 한다. 

put 메서드를 이용하면 버퍼 특정 위치에 long값을 넣을 수 있다.

버퍼 타입은 어느 한 가지로 고정된 게 아니고, 가장 적합한 자료 구조를 선택/관리하는 일은 개발자의 몫이다. 경계 검사 기능 설정/해제가 가능하므로 불필요한 코드는 JIT 컴파일러로 최적화하며 들어낼 수 있다. 

2. **리스트, 맵, 세트**

아그로나는 int 또는 long형 배열에 기반한 리스트 구현체를 여럿 제공한다. 자바는 배열 안에서 객체를 나란히 배치하는 장치가 따로 없으며 표준 컬렉션의 결과물은 항상 레퍼런스의 배열이다.

표준 컬렉션에서 기본형 아닌 객체를 사용하라고 강요하다 보니 객체 자체 크기 오버헤드도 있지만 자동박싱/언박싱도 발생한다. 아그로나 ArrayListUtil을 이용하면 리스트 순서는 안맞지만 ArrayList에서 신속하게 원소를 제거할 수 있다.

아그로나 맵, 세트 구현체는 키/값을 해시 테이블 자료 구조에 나란히 저장한다. 키가 충돌하면 다음 값은 해시 테이블 해당 위치 바로 다음에 저장된다. 동일한 캐시 라인에 있는 기본형 매핑을 빠르게 엑세스할 때 알맞는 자료 구조이다. 

3. **큐**

아그로나 동시성 패키지에는 큐, 링 버퍼를 비롯해 쓸만한 자료 구조 및 동시성 유틸리티가 있다.  아그로나 큐는 `java.util.Queue` 인터페이스를 준수하므로 표준 큐 구현체 대신 사용할 수 있고, 순차 처리용 컨테이너 지원 기능이 부가된 `org.agrona.concurrent.Pipe` 인터페이스도 함께 구현되어 있다. 특히 Pipe는 원소를 카운팅하고 수용 가능한 최대 원소 개수를 반환하고, 원소를 비우는 작업을 지원하므로 큐를 소비하는 코드와 원활하게 상호작용할 있다.

큐는 모두 락-프리하고 Unsafe를 사용하므로 저지연 시스템에 적합하다. `org.agrona.concurrent.AbstractConcurrentArrayQueue` 는 서로 다른 생산자/소비자 모델을 제공하는 일련의 큐를 1차적으로 지원하는 추상 클래스이다. 

생산자, 소비자를 각자 별개의 캐시 라인에 놓아두면 저지연, 고처리율 상황에서 만족할 만한 성능을 기대할 수 있다. 캐시 라인은 메모리를 액세스하기 위해 사용하지만, 생산자, 소비자가 동일한 캐시 라인을 공유하는 구조라면 캐시 라인을 동시 액세스할 때 문제가 불거질 것이다. 

구현체는 다음 세 가지이다. 

- `OneToOneConcurrentArrayQueue`
    - 하나의 생산자, 하나의 소비자는, ‘유일한 동시 엑세스는 생산자, 소비자가 자료 구조에 동시 엑세스할 때만 발생한다’는 정책을 선택하는 것과 같다. 여기서 중요한 건, 한번에 하나의 스레드에 의해서만 업데이트되는 헤드, 테일의 위치이다.
    - 헤드는 큐에서 `poll()` 또는 `drain()` 할 때에만, 테일은 `put()` 할 때에만 업데이트 할 수 있다. 이 모드를 선택하면 나머지 두 가지 큐에서 꼭 필요한, 부수적인 조정 체크를 하느라 쓸데없이 성능 누수를 유발할 일이 없다.
- `ManyToManyConcurrentArrayQueue`
    - 생산자가 다수인 경우엔 테일 위치를 업데이트할 때 부가적인 제어 로직이 필요하다.
    - while 루프에서 `Unsafe.compareAndSwapLong` 를 사용하면 꼬리가 업데이트될 때까지 큐 테일을 안전하게, 락-프리하게 업데이트할 수 있다.
    - 소비자는 하나밖에 없으니 소비자 쪽에는 이런 경합이 없다.
- `ManyToOneConcurrentArrayQueue`
    - 생산자, 소비자 모두 다수일 경우, 머리/테일 양쪽을 업데이트해야 한다. 이 정도 수준으로 조정/제어하려면 compareAndSwap을 감싼 while 루프가 필요하다.
    - 셋 중 조정 과정이 가장 복잡하기 때문에 그만큼 안전이 보장돼야 할 경우에만 사용하는 것이 좋다.
4. **링 버퍼**

아그로나가 제공하는 `org.agrona.concurrent.RingBuffer` 는 프로세스 간 통신용 바이너리 인코딩 메시지를 교환하는 인터페이스이다. `RingBuffer` 는 `DirectBuffer`를 이용해 메시지 오프-힙 저장소를 관리한다. 

아그로나에 내장된 링 버퍼 구현체는 `OneToOneRingBuffer`, `ManyToOneRingBufer` 두 가지이다. 쓰기 작업은 소스 버퍼를 전달 받아 메시지를 별도의 버퍼에 써넣는 반면, 읽기 작업은 메시지 핸들러의 `onMessage()` 메서드로 콜백된다.

`ManyToOneRingBuffer` 에서 여러 생산자가 쓰기하고 있는 상황에서 `Unsafe.storeFence()` 메서드를 호출하면 수동으로 메모리 동기화를 통제할 수 있다. `storeFence()` 는 ‘펜스를 치기 전의 스토어를, 펜스를 친 이후의 로드 또는 스토어와 순서를 바꾸지 못하게 하는’ 메서드이다. 

**단순 바이너리 인코딩**

단순 바이너리 인코딩(SBE)는 저지연 성능에 알맞게 개발된 바이너리 인코딩 방식으로, 금융 시스템에 쓰이는 FIX 프로토콜에 특화되어 있다.

SBE는 메시지를 인코딩/디코딩하는 애플리케이션 계층의 관심사이다. 버퍼는 아그로나에서 빌려 사용한다. SBE는 GC를 유발하지 않고 메모리 엑세스 문제를 최적화하지 않고도 효율적인 자료 구조를 통해 저지연 메시지 전달이 가능하다. 특히, 시장 이벤트에 수 밀리초, 수 나노초 이내로 반응해야 하는 고빈도 거래 환경에 맞춤 설계되었다.

SBE 설계 결정으로는 다음과 같다. 

1. 카피-프리, 네이티브 타입 매핑
    
    복사는 비용이 든다. 자바에선 메모리가 자동 관리되어 객체를 복사하는 실수를 저지르는 일은 없다. SBE의 카피-프리 기술은 중간 버퍼를 쓰지 않고 메시지를 인코딩/디코딩하도록 설계되었다.
    
    하지만 하부 버퍼에 직접 쓰는 작업은 설계 비용이 든다. 버퍼에 집어넣지 못할 정도로 큰 메시지는 지원할 수 없기 때문에 조각조각 나누어 다시 조립하는 프로토콜을 구축해야 이런 메세지도 지원이 가능하다. 
    
    어셈블리 명령어에 네이티브하게 매핑되는 타입도 카피-프리하게 작업하는 게 좋다. 어셈블리 연산을 적절히 잘 선택해 매핑하면 필드 검색 성능이 현저히 향상된다. 
    
2. 정상 상태 할당
    
    저지연 애플리케이션 설계 시 자바의 객체 할당 방식은 당연히 문제가 된다. 할당 작업 자체 또한 TLAB 처럼 아주 작다고 해도 CPU 사이클은 소모하지고, 사용을 마친 후 객체를 지우는 것도 문제다. 
    
    GC는 STW, 즉 중단을 자주 일으킨다. 거의 동시 작동하는 고급 수집기도 마찬가지다. 중단 시간 수치를 제한해도 GC 프로세스는 성능 모델에 유의미한 편차를 가져온다. 
    
    SBE는 하부 버퍼 플라이트웨이트 패턴을 사용하므로 할당-프리하다.
    
3. 스트리밍/단어 정렬 엑세스
    
    자바에서 메모리 액세스는 범접할 수 없는 대상이다. 자바 배열은 보통 레퍼런스 배열 형태라서 메모리 순차 읽기는 불가능하다. 
    
    SBE는 메시지를 진행 방향으로 인코딩/디코딩하도록 설계되어 있어 단어를 정확하게 정렬 할 수 있는 틀이 잡혀 있다. 정렬이 엉망인 상태에선 프로세서 수준에서 성능 문제가 불거질 수 있다.
    

**에어론**

에어론은 SBE와 아그로나에 기반한 툴로 UDP, 유니캐스트, 멀티캐스트, IPC 메시지를 전송하는 수단이다. 

기본적으로 에어론은 애플리케이션이 같은 머신에서, 또는 네트워크를 넘나들며 IPC를 통해 서로 소통할 수 있게 해주는 것들을 망라한, 일반적인 프로토콜이다. 최고의 처리율을 지향하는 에어론은 지연을 예측 가능한 방향으로 가장 낮게 유지하는 것을 목표한다. 

에어론 구성 컴포넌트는 다음과 같다. 

![image1](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/78543382/db645c54-a24a-40bd-9350-161701fed463)

- 미디어 - 에어론이 통신하는 매개체이다. (UDP, IPC 등)
    - 요는 에어론이 클라이언트로서 이 매체들을 모두 추상화했다는 점이다.
- 미디어 드라이버 - 미디어와 에어론 사이 연결 통로로 원하는 전송 구성을 세팅해 통신할 수 있다.
- 감독자 - 전체 흐름을 관장한다.
    - 버퍼 설정를 설정하거나 새 구독자/발행자 요청을 리스닝하는 등의 일을 한다. 또 NAK를 감지해 재전송 준비를 하기도 한다. 감독자 덕분에 송신자/수신자는 바이트를 주고받는 일만 집중해서 최대 처리율을 높일 수 있다.
- 송신자 - 생산자로부터 데이터를 읽어 소켓으로 전송한다.
- 수신자 - 소켓에서 데이터를 읽고 해당 채널/세션으로 내보낸다.

보통 미디어 드라이버는 메시지 송수신에 사용하는 버퍼를 제공하는 별개 프로세스로 떠 있다. 다양한 미디어 드라이버가 준비되어 있어서 하드웨어 배포 환경에 맞게 최적화할 수 있다. `MediaDriver.context` 는 미디어 드라이버별 최적 설정값이 보관된 구성 클래스이다. 또 미디어 드라이버는 동일 프로세스 내부에 임베디드 방식으로도 띄울 수 있다. 임베디드 프로세스는 컨텍스트나 시스템 프로퍼티로 구성할 수 있다.

**에어론 설계 개념**

1. 전송 요건
    
    에어론은 OSI 4 전송 계층에서 메시징을 수행하므로 반드시 준수해야 할 요건들이 있다. 
    
    - 정렬
        - 전송 계층은 저수준에서 무작위 순서로 오는 패킷을 받기 때문에 순서가 뒤섞인 메시지 다시 정렬해야 한다.
    - 신뢰성
        - 데이터가 누락되면 큰 문제가 발생하므로 유실된 데이터는 재전송을 요청해야 한다.
    - 배압
        - 부하가 높아지면 구독자는 압박을 받는다. 따라서 흐름 제어 및 배압 측정 서비스가 지원되어야 한다.
    - 혼잡
        - 네트워크가 포화되면 혼잡이 일어날 수 있다. 저지연 애플리케이션에서는 혼잡이 주 관심사가 되어선 안된다. 에어론은 혼잡 제어 기능을 옵션으로 제공한다. 따라서 저지연 네트워크에 위치한 유저는 이 기능을 끄고, 다른 트래픽에 민감한 유저는 이 기능을 켜서 사용하면 된다. 혼잡 제어는 최적 경로에서 네트워크 용량이 충분한 제품에 영향을 미칠 수 있다.
    - 다중화
        - 전체 성능을 떨어뜨리지 않고 단일 채널에서 다중 정보 스트림을 처리하여 전체 성능을 떨어뜨리면 안 된다.
2. 지연 및 애플리케이션 원칙
    
    에어론은 8개 설계 원칙을 따른다. 
    
    - 정상 상태에서의 가비지-프리 실현
        - 자바 애플리케이션에서 GC 중단은 지연과 불가측성을 일으키는 주원인이다. 에어론은 GC 중단을 방지하기 위해 정상 상태를 보장하도록 설계되어 있기 때문에 이와 동일한 설계 결정을 따르는 애플리케이션에 에어론을 포함시킬 수 있다.
    - 메시지 경로에 스마트 배칭 적용
        - 스마트 배칭은 수신 메시지가 폭주하는 상황을 감안하여 설계된 알고리즘이다.
        - 에어론은 적절한 자료 구조를 이용해 생산자가 공유 리소스에 쓰는 걸 지연시키지 않고도 배칭을 수행한다.
    - 메시지 경로의 락-프리 알고리즘
        - 락킹은 스레드를 블로킹하는 경합을 일으키며, 파킹이나 락에서 깨어나는 과정도 애플리케이션을 느려지게 만든다. 따라서 락을 없애면 느려질 일도 없다.
    - 메시지 경로의 논블로킹 I/O
        - 블로킹 I/O는 스레드를 블로킹하며 깨우는 비용도 무시할 수 없다. 논블로킹 I/O로 수행하면 그럴 일이 없다.
    - 메시지 경로의 비예외 케이스
        - 애플리케이션은 대부분의 시간을 특이 케이스가 아닌, 기본 시나리오를 처리하는데에 소비한다.
        - 물론 특이 케이스도 잘 처리해야 하겠지만, 기본 시나리오의 실행 속도를 제물로 삼아서는 안 된다.
    - 단일 출력기 원칙을 적용
        - 다중 출력기는 큐 엑세스를 고도로 정교하게 제어/조정하는 작업이 수반된다. 단일 출력기를 쓰면 이 과정이 정말 단순해질뿐만 아니라 쓰기 경합도 줄어든다.
        - 에어론 발행 객체는 스레드-안전하며 다중 출력기를 지원하지만 구독자 객체는 스레드마다 하나씩 필요하므로 스레드-안전하지 않다.
    - 공유 안 하는 상태가 더 좋다.
        - 단일 출력기는 큐 경합을 해결하지만 가변 데이터를 공유해야 하는 문제를 유발한다.
    - 쓸데없이 데이터를 복사하지 말라
        - 데이터 복사 비용은 그리 비싸지 않으나 자바, C++ 모두 캐시 라인 무효화 및 다른 데이터 방출 가능성은 언제라도 문제가 될 수 있다. 복사를 가급적 줄이면 우발적인 메모리 변경을 방지하는 데 도움이 된다.
3. 내부 작동 원리
    
    기존 프로토콜은 대부분 효율적인 메시지 처리 시스템을 구축하기 위해 스킵 리스트 같은 복잡한 자료 구조를 동원한다. 복잡도는 주로 포인터 간접화 탓에 가중되는데, 결국 시스템의 지연 양상을 더욱 예측하기 힘들게 만든다. 
    
    에어론은 최대한 깔끔하고 단순한 방식으로 자료 구조에 메시지 시퀀스를 생성한다. 별로 좋은 선택 같지는 않으나 에어론은 파일 개념을 폭넓게 활용한다. 파일은 서로 연관된 프로세스끼리 공유 가능한 매개체이다. 리눅스의 메모리 맵 파일 아키텍처 덕분에 모든 파일 호출은 실제 물리적인 파일을 쓰는 게 아니라 메모리로 전달된다. 
    
    테일 포인터는 최종 메시지가 쓰인 지점을 찾아가는 용도로 쓰인다. 다음은 현재 파일에 헤더를 지닌 단일 메시지를 쓰는 장면이다. 
    
![image2](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/78543382/8f1dcf0d-9ad5-431b-b40b-6b63c90b5063)

    
  테일 포인터는 파일 내부에 메시지 공간을 예약한다. 테일 증분 작업은 아토믹하므로 출력기는 자기 영역의 처음과 끝이 어디인지 잘 알고 있다. 덕분에 다중 출력기가 락-프리하게 파일을 업데이트할 수 있고 파일 쓰기 프로토콜을 매우 효율적으로 작동시킬 수 있다. 
    
  파일을 쓰면 점점 커지지만 가만 놔두면 변하지 않는 영속적인 개체이다. 파일에서 그냥 데이터를 읽기만 할 때에는 프로세스가 읽기 전용 모드로 열기 때문에 락은 필요 없다. 파일을 한없이 커지도록 방치하면 방금 전 살펴봤던 메모리 맵 파일에서 페이지 폴트 같은 별의별 문제가 발생할 것이다. 이 문제는 파일을 액티브, 더티, 클린 세 파일로 두어 해결한다. 액티브는 현재 쓰고 있는 파일, 더티는 이전에 쓰인 파일, 클린은 바로 다음에 쓸 파일이다. 큰 파일 때문에 지연되지 않도록 계속 파일을 순환시킨다. 
    
  어떤 경우에도 메시지는 여러 파일을 넘나들 수 없다. 테일이 액티브 파일 끝에서 밀려나면, 삽입 프로세스는 파일의 나머지 부분을 채우고 메시지를 클린 파일에 쓴다. 트랜잭션 로그는 더티 파일에서 꺼내 아카이빙 할 수 있다.
    
  누락된 메시지를 처리하는 메커니즘에서 스킵 리스트 등의 자료 구조는 필요 없다. 메세지 헤더 자체에 메세지 순서가 있기 때문이다. 메시지 삽입 시 순서가 안 맞으면 이전 메시지용 공간을 비우기 때문에 유실된 메시지가 들어오면 파일의 정확한 위치에 삽입할 수 있다. 이런 식으로 일체의 간극이나 다른 자료 구조 없이 계속 증가하는 메시지 시리즈를 만들 수 있다. 
    
  워터마크는 최종 수신 메시지의 현재 위치이다. 워터마크 및 테일이 일정 기간 동안 상이하다면 그건 메시지가 누락되었음을 의미한다. 유실된 메시지는 복구해야 하므로 NAK를 보내 다시 요청하면 된다. 
    
  이 프로토콜에서 한 가지 흥미로운 부수효과가 발생하는데, 모든 수신 메시지가 streamId, sessionId, termId, termOffset에 따라 각 메시지의 바이트를 식별하는 고유한 방식으로 가진다는 것이다. 에어론 아카이브는 메시징 스트림을 기록/재색하는 용도로 쓰인다. 이 고유한 표현 방식과 아카이브를 결합하면 역사상 모든 메시지를 유일하게 식별하는 것도 가능하다.