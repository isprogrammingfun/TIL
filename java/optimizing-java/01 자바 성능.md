## 자바 성능

자바 초창기에 메서드 디스패치 성능은  최악이었으나, 시간이 지나며 매우 좋아짐.

특히 JVM에서는 자동 인라이닝 덕분에 가상 디스패치조차 대부분의 호출부에서 사라지게 되었다.

> 자동 인라이닝?
> 
> 
> 먼저, 인라이닝이란 가장 자주 실행되는 메서드의 호출을 해당 메서드의 내용으로 치환하여 실행 시점(런타임 시점) 에 컴파일된 소스 코드를 최적화하는 방법이다. 즉, 인라이닝은 컴파일러가 메서드 호출을 분석하여 호출된 메서드의 내용을 호출부로 복사하여 대체함으로써 실행 시에 추가적인 메서드 호출 오버헤드를 없애고 성능을 향상시킨다. 컴파일이 포함되어 있지만, 전통적인 javac 컴파일러에 의해 수행되는 것이 아니라 JVM 자체에 의해 수행된다. 더 정확히 말하면 JVM의 일부인 JIT(Just-In-Time) 컴파일러의 책임이다. javac은 바이트 코드만 생성하고 JIT가 소스 코드를 최적화하도록 한다. 이 접근 방식의 가장 중요한 결과 중 하나는, 이전 버전의 Java로 코드를 컴파일하더라도 동일한 .class 파일이 더 최신 JVM에서 더 빠를 수 있다는 점이다. 따라서 소스 코드를 다시 컴파일할 필요 없이 Java만 업데이트하면 된다. 인라이닝은 개발자가 명시적으로 지정하거나 컴파일러에 의해 수행되고, 자동 인라이닝은 컴파일러나 인터프리터가 자동으로 인라이닝을 수행한다. 
> 

> 가상 디스패치? <br>
먼저, 디스패치란 어떤 메서드를 호출할 것인가를 결정하는 과정이다. 즉, 메서드의 의존성을 결정하는 과정이다. 디스패치에는 2가지가 있다. <br>
1.정적인 디스패치 (Static Dispatch) <br>
런타임이 아닌 컴파일타임에 컴파일러, 사용자, 바이트코드 모두 어떤 메서드가 실행될지 아는 것 <br>
2.동적인 디스패치 (Dynamic Dispatch) <br>
어떤 메서드를 실행시킬까를 런타임에 결정하게 되는 것 <br>
가상 디스패치는 객체 지향 프로그래밍에서 다형성을 구현하기 위한 매커니즘이다. 가상 디스패치는 다형성을 지원하기 위해 메서드 호출을 동적으로 연결하는 과정을 의미한다. 일반적으로 객체 지향 언어에서 메서드 호출은 컴파일 시점에 정적으로 결정되는데, 다형성에서는 실제로 실행되는 객체의 타입에 따라 다른 메서드가 호출되어야 한다. 가상 디스패치는 이런 다형성을 지원하기 위해 런타임 시점에 객체의 실체 타입을 검사하고, 해당하는 메서드를 동적으로 선택한다. 이를 위해 객체에 대한 가상 함수 테이블 또는 가상 메서드 테이블을 사용해 메서드 호출을 동적으로 연결한다. 가상 함수 테이블은 객체의 타입에 따라 정의된 가상 메서드의 주소를 포함하고 있으며, 메서드 호출 시에 이 테이블을 참조하여 실제로 실행할 메서드를 선택한다. 가상 디스패치는 동적 디스패치의 한 구현 방식이다. 동적 디스패치는 런타임시에 메서드 호출을 결정하는 일반적인 개념을 가지고 있는 것이고, 가상 디스패치는 이를 가상 함수 테이블을 사용해 구체화한 형태이다.
> 

> 호출부? <br>
동적 메서드 호출을 나타내는 지점을 의미한다. 동적으로 호출되는 메서드나 함수의 위치를 가리키는 특정 코드 구문이다.
> 

즉, 정리하자면 자동 인라이닝은 컴파일 타임에 메서드 호출을 대체하는 것이므로, 인라인된 메서드의 내용은 컴파일된 시점에서 결정된다. 따라서 호출부에는 메서드 호출을 인라인된 코드로 대체하는 것이 가능하며, 이로 인해 가상 디스패치가 호출부에서 사라진다. 

모든 최적화 기법에는 개발자가 사용하기 전에 알아두어야 할 함정과 트레이드오프가 있으니 조심해야 한다. 

## 자바 성능 개요

자바는 처음부터 지극히 실용적인 언어로 개발 환경이 충분히 빠르다면 개발자 생산성이 높아지는 대가로 어느 정도의 성능 희생은 감수하는 입장을 취한다. 

자바 환경이 고성능 컴퓨팅 에플리케이션에 적합한 수준에 이른 건 비교적 최근에 핫스팟 같은 정교한 JVM이 성숙했기 때문이다.

실용성을 추구하는 자바 플랫폼의 성격을 대표적으로 보여주는 것은 관리되는 서브시스템이다. 이는 개발자가 일일이 용량을 세세하게 관리하는 부담을 덜어주고, 대신 저수준으로 제어 가능한 일부 기능을 포기하자는 발상이다. 

> 관리되는 서브시스템? <br>
관리되는 서브시스템(Managed Subsystem)은 시스템 또는 소프트웨어 구성 요소 내에서 특정 기능 또는 서비스를 제공하기 위해 관리되고 제어되는 독립적인 하위 시스템이다. 이는 주로 대규모 시스템이나 소프트웨어 아키텍처에서 사용되며, 전체 시스템의 기능을 분할하고 모듈화하여 관리 가능성을 향상시킨다. 일반적으로 특정 기능 영역이나 도메인을 담당하며, 그 자체로 독립된 기능을 제공하고 제어된다.
> 

JVM 애플리케이션의 성능 측정값은 정규 분포를 따르지 않는 경우가 많아서 기초 통계 기법만 가지고 측정 결과를 제대로 처리하기는 어렵다. 

JVM 애플리케이션에서 특이점은 매우 중요한 의미를 내포할 수 있으므로 측정값을 샘플링하면 특이점을 일으킨 가장 중요한 이벤트가 묻혀버릴 가능성이 크다. 

자바 성능 측정값 때문에 판단이 흐려지기 쉬우므로 조심해야 한다. 환경이 복잡해질수록 시스템을 개별적으로 따로 떼어내 생각하기 매우 어렵다.

측정하는 행위 자체도 오버헤드를 일으키며, 너무 자주 샘플링하거나 매번 결과를 기록하는 것 역시 성능 결과 수치에 적잖은 영향을 끼친다. 자바 성능 수치는 일정 부분 세심한 손질이 필요하기 때문에 우직한 기법으로 접근하면 부정확한 결과가 나올 공산이 크다. 

## 성능은 실험과학이다

자바/JVM 소프트웨어 스택은 매우 복잡하다. 본인이 처한 환경에 적응하며 고도로 최적화하는 JVM을 기반으로 구축된 운영 시스템의 성능 양상은 상당히 미묘하고 복잡하게 나타날 수 있다. JVM도 다른 복잡한 고성능 시스템처럼 최상의 성능을 발휘하려면 어느 수준 이상의 스킬과 경험이 필요하다.

JVM 성능 튜닝은 기술, 방법론, 정량적 측정값, 툴을 망라한 개념으로, 목표는 시스템 소유자/유저가 추구하는 측정 결과를 얻는 것이다. 성능은 다음과 같은 활동을 하며 원하는 결과를 얻는 일종의 실험과학이다.

- 원하는 결과를 정의한다
- 기존 시스템을 측정한다
- 요건을 충족시키려면 무슨 일을 해야 할지 정한다
- 개선 활동을 추진한다
- 다시 테스트한다
- 목표가 달성됐는지 판단한다

이런 과정에서 정량적인 일련의 목표가 수립된다. 무엇을 측정할지 대상을 확정하고 목표를 기록하는 행위가 중요한데, 결국 이런 활동들이 프로젝트 아티팩트(결과물)와 제품 일부를 형성한다. 성능 분석은 비기능 요건을 정의하고 달성하는 활동이다. 

## 성능 분류

### 처리율

시스템이 수행 가능한 작업 비율을 나타낸 지표이다. 보통 일정 시간 동안 완료한 작업 단위 수로 표시한다. 

처리율이 실제 성능을 반영하는 의미 있는 지표가 되려면 수치를 얻은 기준 플랫폼에 대해서도 내용(하드웨어 스펙, OS, 소프트웨어 스택 등등) 을 기술해야 한다. 그리고 트랜잭션은 테스트할 때 마다 동일해야 한다. 처리율을 테스트할 때 실행 간 워크로드(시스템이 주어진 시간 내에 처리해야 할 작업 할당량) 역시 일정하게 유지해야 한다. 

### 지연

하나의 트랜잭션을 처리하고 결과를 얻을 때까지 소요된 시간이다. 종단 시간이라고도 하며, 대개 그래프에서 워크로드에 비례하는 함수로 표시한다. 

### 용량

시스템이 보유한 작업 병렬성의 총량, 즉 시스템이 동시 처리 가능한 작업 단위(트랜잭션) 개수를 말한다.

용량은 처리율과 밀접한 연관이 있다. 시스템에 동시 부하가 증가할수록 처리율 또한 영향을 받으므로 보통 용량은 어떤 처리율 또는 지연 값을 전제로 가능한 처리량으로 표시한다. 

### 사용률

성능 분석 업무 중 가장 흔한 테스크는 시스템 리소스를 효율적으로 활용하는 것이다. 사용률은 워크로드에 따라서 리소스별로 들쑬날쑥할 수 있다. 예를 들어 그래픽 처리나 암호화 같은 계산 집약적 워크로드를 주면 CPU 사용률은 매우 높지만, 메모리 사용률은 얼마 안 나온다. 

### 효율

처리율을 리소스 사용율로 나눈 값으로 측정한다. 같은 처리율을 더 많은 리소스를 사용해 달성할 수 있다면 효율이 낮은 것인다. 

### 확장성

처리율이나 시스템 용량은 처리하는 데 끌어 쓸 수 있는 리소스에 달려 있다. 리소스 추가에 따른 처리율 변화는 시스템/애플리케이션의 확장성을 가늠하는 척도이다. 시스템 확장성은 궁극적으로 정확히 리소스를 투입한 만큼 처리율이 변경되는 형태를 지향한다. 그러나 보통 시스템 확장성은 하나의 단순한 상수 인자가 아니라, 여러 가지 인자들의 영향을 받는다. 리소스를 어느 정도까지 늘리면 거의 선형적으로 확장되지만, 대부분 부하가 높아지면 완벽한 확장을 저해하는 한계점에 봉착하게 된다. 

### 저하

요청 개수가 증가하건, 요청 접수 속도가 증가하건, 어떤 형태로든 시스템이 더 많은 부하를 받으면 지연 그리고/또는 처리율 측정값에 변화가 생긴다. 시스템을 덜 사용하고 있으면 측정값이 느슨하게 변하지만, 시스템이 풀 가동된 상태면 처리율이 더 늘어나지 않는 지연이 증가하는 양상을 보이는데, 이 현상을 부하 증가에 따른 저하라고 한다. 

### 측정값 사이의 연관 관계

다양한 성능 측정값은 어떤 식으로든 서로 연결돼 있다. 또 구체적인 상호 관계는 시스템이 풀 가동 중인지 여부에 따라 달라진다. 

## 성능 그래프

### 성능 엘보

부하가 증가하면서 예기치 않게 저하가 발생한 그래프이다. 

### 준-선형적 확장

클러스터에 장비를 추가함에 따라 거의 선형적으로 처리율이 확장되는 케이스이다. 이런 결과는 환경이 극단적으로 순조로울 때 ( 서버 하나에 세션 어피니티가 필요없는 무상태 프로토콜을 확장하는 경우) 가능하다.

### 암달의 법칙

태스크를 처리할 때 프로세서 개수를 늘려도 실행 속도를 최대 어느 정도까지 높일 수 있는지를 나타낸 그래프이다. 암달에 따르면 근본적으로 확장성에는 제약이 따르는데, 그래프를 보면 워크로드에 반드시 순차 실행되어야 할 작업 조각이 하나라도 있으면 선형 확장은 처음부터 불가하고 확장 가능한 한계점도 뚜렷하다는 사실을 알 수 있다.

### 건강한 메모리 사용

JVM 가비지 수집 서브시스템의 메모리 사용 패턴은 그 하부 기술 때문에 부하가 별로 없는 건강한 애플리케이션도 톱니 모양을 나타낸다. 

### 문제가 있는 할당률 분포

애플리케이션에서 메모리 할당률은 성능 튜닝할 때 매우 중요한 메모리 그래프이다. 할당률이 급격하게 떨어지는 지점에서 애플리케이션에 심각한 가비지 수집 문제가 발생했고, 가비지 수집 스레드들이 서로 CPU 경합을 벌인 탓에 메모리를 충분히 할당받지 못함을 알 수 있다. 

### 부하가 높을 때 지연 발생

시스템 리소스가 누수될 때 흔히 나타나는 징후이다. 부하가 증가하면서 지표가 차츰 악화되다가 결국 시스템 성능이 급락하는 변곡점에 이르게 된다.