## 가비지 수집 기초

자바 가비지 수집의 요체는, 시스템에 있는 모든 객체의 수명을 정확히 몰라도 런타임이 대신 객체를 추적하며 쓸모없는 객체를 알아서 제거하는 것이다. 이렇게 자동 회수한 메모리는 깨끗이 비우고 재활용할 수 있다. 

모든 가비지 수집 구현체는 다음 두 가지 기본 원칙을 준수해야 한다

1. 알고리즘은 반드시 모든 가비지를 수집해야 한다.
2. 살아 있는 객체는 절대로 수집해선 안 된다.

이때, 두 번째 원칙이 더 중요하다. 살아 있는 객체를 수집했다간 세그먼테이션 결함이 발생하거나 프로그램 데이터가 조용히 더럽혀진다. 자바 GC 알고리즘은 프로그램이 사용 중인 객체를 절대 수집해선 안 된다. 

프로그래머가 저수준 세부를 일일이 신경쓰지 않는 대가로 저수준 제어권을 포기한다는 사상이 바로 자바 관리 방식의 핵심이며, 제임스 고슬링이 블루칼라 언어라고 말한 특징이 잘 드러나는 대목이다. 

## 마크 앤 스위프

가장 초보적인 마크 앤 스위프 알고리즘은 할당됐지만, 아직 회수되지 않은 객체를 가리키는 포인터를 포함한 할당 리스트를 사용한다. 전체적인 GC 알고리즘은 다음과 같다.

1. 할당 리스트를 순회하면서 마크 비트를 지운다. 마크 비트를 지운다는 것은 해당 객체가 더 이상 참조되지 않음을 의미한다.
2. GC 루트부터 살아 있는 객체를 찾는다.
3. 이렇게 찾은 객체마다 마크 비트를 세팅한다.
4. 할당 리스트를 순회하면서 마크 비트가 세팅되지 않은 객체를 찾는다.
    1. 힙에서 메모리를 회수해 프리 리스트에 되돌린다.
    2. 할당 리스트에서 객체를 삭제한다. 

![image](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/78543382/2d5b7854-e9d8-4735-87a4-4da60f098d73)


살아 있는 객체를 대부분 깊이-우선 방식으로 찾는다. 이렇게 해서 생성된 객체 그래프를 라이브 객체 그래프라고 하며, 접근 가능한 객체의 전이 폐쇄라고도 한다. 

### 가비지 수집 용어

1. STW
    
    GC 사이클이 발생하여 가비지를 수집하는 동안에는 모든 애플리케이션 스레드가 중단된다. 따라서 애플리케이션 코드는 GC 스레드가 바라보는 힙 상태를 무효화할 수 없다.  단순 GC 알고리즘에서는 대부분 이럴 때 STW가 일어난다.
    
2. 동시
    
    GC 스레드는 애플리케이션 스레드와 동시 실행될 수 있다. 그러나 이는 계산 비용 면에서 아주 어렵고 비싼 작업인 데다, 실상 100% 동시 실행을 보장하는 알고리즘은 없다. 
    
3. 병렬
    
    여러 스레드를 동원해서 가비지 수집을 한다.
    
4. 정확
    
    정확한 GC 스킴은 전체 가비지를 한번에 수집할 수 있게 힙 상태에 관한 충분한 타입 정보를 지니고 있다. 대략 int와 포인터의 차이점을 언제나 분간할 수 있는 속성을 지닌 스킴이 정확한 것이다.
    
5. 보수
    
    보수적인 스킴은 정확한 스킴의 정보가 없다. 그래서 리소스를 낭비하는 일이 잦고 근본적으로 타입 체계를 무시하기 때문에 훨씬 비효율적이다.
    
6. 이동
    
    이동 수집기에서 객체는 메모리를 여기저기 오갈 수 있다. 즉, 객체 주소가 고정된 게 아니다. 맨포인터로 직접 액세스하는 환경은 이동 수집기와 잘 맞지 않는다. 
    
7. 압착
    
    할당된 메모리는 GC 사이클 마지막에 연속된 단일 영역으로 배열되며 객체 쓰기가 가능한 여백의 시작점을 가리키는 포인터가 있다. 압착 수집기는 메모리 단편화를 방지한다. 
    
    - 메모리 단편화 : 동적으로 할단된 메모리 영역에서 사용 가능한 메모리 블록들이 작고 조각화 되어 분산된 상태
8. 방출
    
    수집 사이클 마지막에 할당된 영역을 완전히 비우고 살아남은 객체를 모두 다른 메모리 영역으로 이동한다.
    

## 핫스팟 런타임 개요

GC 용어뿐만 아니라, 구현체에 특정한 용어도 있다. 

자바 언어에서는 기본형(byte, int등)과 객체 레퍼런스 이 두 가지 값만 사용한다. 

자바는 c++과 달리 주소를 역참조하는 일반적인 매커니즘이 없고, 오직 오프셋 연산자 만으로 필드에 엑세스하거나 객체 레퍼런스의 메서드를 호출할 수 있다. 또 자바는 값으로 호출하는 방식으로만 메서드를 호출한다. 

### 객체를 런타임에 표현하는 방법

핫스팟은 런타임에 oop라는 구조체로 자바 객체를 나타낸다. oop는 참조형 지역 변수 안에 위치한다. 여기서 자바 메서드의 스택 프레임으로부터 자바 힙을 구성하는 메모리 영역 내부를 가리킨다. 

oop를 구성하는 자료 구조 중 instanceOop는 자바 클래스의 인스턴스를 나타낸다. 

instanceOop의 메모리 레이아웃은 모든 객체에 대해 기계어 워드 2개로 구성된 헤더로 시작한다. Mark 워드(인스턴스 관련 메타데이터를 가리키는 포인터)가 먼저 나오고, 그 다음은 Klass 워드(클래스 메타데이터를 가리키는 포인터)가 나온다. 

자바 7까지는 instanceOop의 Klass 워드가 자바 힙의 힐부인 펌젠이라는 메모리 영역을 가리켰다. 자바 힙에 있는 건 예외 없이 객체 헤더를 갖고 다녀야 한다는 게 기본 원칙이었고, 실제로 자바 옛 버전은 메타데이터를 klassOop로 참조했다. klassOop의 메모리 레이아웃은 정말 단순해서 그냥 객체 헤더 바로 다음에 klass 메타데이터가 나온다.

자바 8부터는 Klass가 자바 힙의 주 영역 밖으로 빠지게 되었다. 그래서 최신 버전의 자바는 Klass 워드가 자바 힙 밖을 가리키므로 객체 헤더가 필요없다. 

klassOop 앞에 k를 붙인 것은 자바 Class 객체를 나타내는 instanceOop와 구분하기 위해서다.

![image (1)](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/78543382/571f34d1-8925-4755-9111-390432664291)

klassOop에는 클래스용 가상 함수 테이블(vtable)이 있지만, class 객체에는 리플렉션으로 호출할 Method 객체의 레퍼런스 배열이 담겨 있다. 

oop는 대부분 기계어 워드라서, 예전 32비트 프로세서는 32비트, 요즘 프로세서는 64비트이다. 그런데 이런 구조로는 메모리가 크게 낭비될 우려가 있기 때문에 핫스팟은 조금이라도 메모리를 절약할 수 있게 압축 oop라는 기법을 제공한다. 힙에 있는 모든 객체의 Klass워드, 참조형 인스턴스 필드, 객체 배열의 각 원소가 압축된다. 

핫스팟 객체 헤더는 일반적으로 다음과 같이 구성된다

- Mark 워드 (32비트 환경은 4바이트, 64비트 환경은 8바이트)
- Klass워드(압축됐을 수도 있다)
- 객체가 배열이면 length 워드 (항상 32비트)
- 32비트 여백(정렬 규칙 때문에 필요할 경우)

객체 인스턴스 필드는 헤더 바로 다음에 나열된다. kladdOop는 Klass 워드 다음에 메서드 vtable이 나온다. 

![image (2)](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/78543382/75a84214-df7c-4e27-a4fe-d9678b5af7cb)

압축 oop 옵션을 끄면 성능이 개선되기도 했지만 매우 미미하다.
자바에서 배열은 객체에 해당한다. 그래서 JVM의 배열도 oop로 표현된다.
배열은 Mark 워드, Klass워드 다음에 length 워드가 붙어 배열의 길이를 명시한다.

JVM 환경에서 자바 레퍼런스는 instanceOop를 제외한 어떤 것도 가리킬 수 없다. 저수준에서는 다음과 같은 의미이다.

- 자바 값은 기본형 값 또는 instanceOop 주소(레퍼런스_에 대응되는 비트 패턴이다.
- 모든 자바 레퍼런스는 자바 힙의 주 영역에 있는 주소를 가리키는 포인터라고 볼 수 있다.
- 자바 레퍼런스가 가리키는 주소에는 Mark 워드 + Klass 워드가 들어 있다.
- klassOop와 Class<?> 인스턴스는 다르며, klassOop을 자바 변수 안에 넣을 수 없다.

### GC 루트 및 아레나

GC 루트는 메모리의 고정점으로 메모리 출 외부에서 내부를 가리키는 포인터(외부 포인터)이다.

GC 루트의 종류는 다음과 같이 다양하다.

- 스택 프레임
- JNI
- 레지스터
- 코드 루트
- 전역 객체
- 로드된 클래스의 메타데이터

핫스팟 GC는 아레나라는 메모리 영역에 작동한다. 

핫스팟은 자바 힙을 관리할 때 시스템 콜을 하지 않는다. 핫스팟은 유저 공간 코드에서 힙 크기를 관리하므로 단순 측정값을 이용해 GC 서브시스템이 어떤 성능 문제를 일으키고 있는지 파악할 수 있다.

## 할당과 수명

자바 애플리케이션에서 가비지 수집이 일어나는 주된 원인은 다음 두가지이다.

1. 할당률
2. 객체 수명

할당률은 일정 기간 새로 생성된 객체가 사용한 메모리량이다. JJVM은 할당률을 직접 기록하지 않지만, 이 값은 비교적 쉽게 측정할 수 있고 센섬 같은 툴을 쓰면 정확하게 구할 수 있다. 

반면, 객체 수명은 대부분 측정하기 어렵다. 실제 애플리케이션에서 객체 수명을 제대로 파악하기가 너무 복잡하다. 그 결과, 객체 수명이 할당률보다 더 핵심적인 요인이다. 

가비지 수집은 ‘메모리를 회수해 재사용’하는 일이다. 객체는 대부분 단명하므로 가비지 수집에서 핵심 전제는 동일한 물리 메모리 조각을 몇 번이고 계속 다시 쓸 수 있는가. 하는 점이다.

객체가 생성된 후 잠시 존재하고 그 상태를 보관하는 데 사용한 메모리를 다시 회수한다는 발상이 핵심이다. 

### 약한 세대별 가설

약한 세대별 가설은 소프트웨어 시스템의 런타임 작용을 관찰한 결과 알게 된 경험 지식으로, JVM 메모리 관리의 이론적 근간을 형성한다. 

**JVM 및 유사 소프트웨어 시스템에서 객체 수명은 이원적 분포 양상을 보인다. 거의 대부분의 객체는 아주 짧은 시간만 살아있지만, 나머지 객체는 기대 수명이 훨씬 길다.**

결론적으로, 가비지를 수집하는 힙은, 단명 객체를 쉽소 빠르게 수집할 수 있게 설계해야 하며, 장수 객체와 단명 객체를 완전히 떼어놓는 게 가장 좋다. 

핫스팟은 몇 가지 매커니즘을 응용하여 약한 세대별 가설을 활용한다.

- 객체마다 세대 카운트(객체가 지금까지 무사 통과한 가비지 수집 횟수)를 센다.
- 큰 객체를 제외한 나머지 객체는 에덴 공간에 생성한다. 여기서 살아남은 객체는 다른 곳으로 옮긴다.
- 장수했다고 할 정도로 충분히 오래 살아남은 객체들은 별도의 메모리 영역(올드 또는 테뉴어드)에 보관한다.

![image (3)](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/78543382/ffd20654-5ebe-4f9a-83f4-b50f08787d87)

여기서 중요한 건 외부에서 영세대 내부를 가리키는 포인터를 계속 추적하는 방법이다. 이 덕에 GC사이클에서 살아남은 젊은 객체들을 집어내르라 전체 객체 그래프를 다 뒤질 필요가 없다.

핫스팟은 카드 테이블이라는 자료구조에 늙은 객체가 젊은 객체를 참조하는 정보를 기록한다. 카드 테이블은 JVM이 관리하는 바이트 배열로, 각 원소는 올드 세대 공간의 512바이트 영역을 가리킨다.

## 핫스팟의 가비지 수집

자바는 C/C++ 계열의 환경과 달리 OS를 이용해 동적으로 메모리를 관리하지 않는다. 대신, 일단 프로세스가 시작되면 JVM은 메모리를 할당하고 유저 공간에서 연속된 단일 메모리 풀을 관리한다. 

이 메모리 풀은 각자의 목적에 따라 서로 다른 영역으로 구성되며, 객체는 보통 에덴 영역에 생성된다. 수집기가 줄곧 객체를 이동시키기 때문에 객체가 차지한 주소는 대부분 시간이 흐르면서 아주 빈번하게 바뀐다. 이 처럼 객체를 이동시키는 것을 ‘방출’이라고 한다. 핫스팟 수집기는 대부분 방출 수집기이다. 

### 스레드 로컬 할당

JVM은 성능을 강화하여 에덴을 관리한다. 에덴은 대부분의 객체가 탄생하는 장소이고, 단명 객체는 다른 곳에는 위치할 수 없으므로 특별히 관리를 잘해야 하는 영역이다. 

JVM은 에덴을 여러 버퍼로 나누어 각 애플리케이션 스레드가 새 객체를 할당하는 구역으로 활용하도록 배포한다.  이 구역을 스레드 로컬 할당 버퍼(TLAB)라고 한다. 

핫스팟은 애플리케이션 스레드에 발급한 TLAB 크기를 동적으로 조정한다.

각 애플리케이 스레드가 TLAB를 다 채우면 JVM은 새 에덴 영역을 가리키는 포인터를 내준다.

### 반구형 수집

반구형(방출) 수집기는 두 공간을 사용하는 독특한 방출 수집기이다. 실제로 장수하지 못한 객체를 임시 수용소에 담아 두자는 아이디어이다. 덕분에 단명 객체가 테뉴어드 세대를 어지럽히지 않게 하고 풀 GC 발생 빈도를 줄일 수 있다. 이 두 공간은 두 가지 기본적인 특성을 지닌다.

- 수집기가 라이브 반구를 수집할 때 객체들은 다른 반구로 압착시켜 옮기고 수집된 반구를 비워서 재사용한다.
- 절반의 공간은 항상 완전히 비운다

핫스팟은 이 반구형 기법과 에덴 공간을 접목시켜 영 세대 수집을 한다.

핫스팟에서는 영 힙의 반구부를 서바이버 공간이라고 한다. 일반적으로 서바이버 공간은 에덴보다 작으며, 이 공간의 역할은 각 영 세대 수집을 교환하는 것이다. 

## 병렬 수집기

자바 8 이전까지 JVM 디폴트 가비지 수집기는 병렬 수집기이다. 병렬 수집기는 처리율에 최적화되어 있고 영 GC, 풀 GC 모두 풀 STW를 일으킨다. 애플리케이션 스레드를 모두 중단시킨 다음, 가용 CPU 코어를 총동원해 가능한 한 재빨리 메모리를 수집한다. 병렬 수집기의 종류는 다음과 같다.

- Parallel GC : 가장 단순한 영 세대용 병렬 수집기이다.
- ParNew GC : CMS 수집기와 함께 사용할 수 있게 Parallel GC를 조금 변형한 것이다.
- ParallelOld GC : 올드 세대용 병렬 수집기이다.

### 영 세대 병렬 수집

영 세대 수집은 가장 흔한 가비지 수집 형태이다. 스레드가 에덴에 객체를 할당하려는데 자신이 할당받은 TLAB 공간은 부족하고 JVM은 새 TLAB를 할당할 수 없을 때 영 세대 수집이 발생한다. 

스레드가 TLAB 밖에 객체를 할당할 수도 있지만, 이러한 논 TLAB 할당률은 가급적 낮추는게 좋다.

영 세대 수집이 일어나면 JVM은 어쩔 수 없이 전체 애플리케이션 스레드를 중단시킨다. 

영 세대 병렬 수집은 다음과 같은 단계로 진행된다.

1. 전체 애플리케이션 스레드가 중단되면 핫스팟은 영 세대를 뒤져서 가비지 아닌 객체를 골라낸다. 이때 GC루트를 병렬 마킹 스캔 작업의 출발점으로 삼는다.
2.  Parallel GC는 살아남은 객체를 현재 비어 있는 서바이버 공간으로 모두 방출한 후, 세대 카운트를 늘려 한 차례 이동했음을 기록한다.
3. 에덴과 이제 막 객체들을 방출시킨 서바이버 공간을 재사용 가능한 빈 공간으로 표시하고, 애플리케이션 스레드를 재시작해 TLAB 애플리케이션 스레드에 배포하는 프로세스를 재개한다. 

![image (4)](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/78543382/d3c7d2bd-9a13-4c17-be52-4a198c55c8f1)

![image (5)](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/78543382/55724163-cd2c-4c8c-823b-1a7ac5e0b7a5)

살아 있는 객체만 건드려 약한 세대별 가설의 이점을 최대한 활용하고, 가능한 코어를 총동원해 STW 중단 시간을 조금이라도 단축해 가비지를 효율적으로 수집하겠다는 의도이다. 

### 올드 세대 병렬 수집

ParallelOld GC는 현재(자바 8 기준) 디폴트 올드 세대 수집기이다. Parallel GC와 상당히 비슷하지만, 근본적인 차이점이 있다. Parallel GC는 객체를 방출하는 반구형 수집기이지만, ParallelOld GC는 하나의 연속된 메모리 공간에서 압착하는 수집기이다. 

올드 세대에 더 이상 방출할 공간이 없으면 병렬 수집기는 올드 세대 내부에서 객체들을 재배치해서 늙은 객체가 죽고 빠져 버려진 공간을 회수하려 한다. 따라서 메모리 사용 면에서 아주 효율적이고 메모리 단편화가 일어날 일도 없다. 

![image (6)](https://github.com/JSON-loading-and-unloading/Optimizing-Java/assets/78543382/504da8e0-c3c6-41be-85f7-c8121bacdc19)

영 세대 수집은 단명 객체 처리가 목적이기 때문에 영 공간의 점유 상태는 GC 이벤트가 발생할 때 마다 메모리 할당 및 소거가 일어나면서 급격히 변한다.

반면, 올드 공간은 이따금 큰 객체가 테뉴어드 세대에 직접 생성될 때도 있지만, 그밖에는 영 세대 객체가 승격되거나, 올드/풀 수집이 일어나 객체를 재 탐색 후 다시 배치하는 등의 수집이 일어날 때만 변한다. 

### 병렬 수집기의 한계

병렬 수집기는 세대 전체 콘텐츠를 한번에, 가능한 효율적으로 가비지를 수집한다. 

그러나 이런 설계 방식에도 단점이 있다. 

- 풀 STW 유발 : 영 수집에서는 STW가 문제 되지 않지만, 올드 수집에서는 문제가 크다.
- 손쉽게 스레드를 생성할 수 있지만, 새 스레드는 곧 실행 스택을 의미하고 실행 스택의 각 프레임은 GC 루트의 원천이므로 가비지 수집 관점에서 보면 전체적인 모양새가 점점 더 복잡해진다.

## 할당의 역할

GC 사이클은 하나 이상의 힙 메모리 공간이 꽉 채워져 더 이상 객체를 생성할 공간이 없을 때 일어난다.

GC 사이클은 어떤 고정된, 예측 가능한 일정에 맞춰 발생하는 게 아니라, 순전히 그때그때 필요에 의해 발생한다.

그래서 가비지 수집 로그는 기존의 시계열 해석 방법으로 처리하기 어렵다. 

약한 세대별 가설에 따르면, 객체 수명은 고정된 게 아니라 어떤 분포를 보이며, 이 분포가 불확실한 탓에 결국 일부 객체는 테뉴어드에 도달할 것이다.

할당률은 실제로 아주 심하게 변하거나 갑자기 확 치솟기도 하는데, 할당률이 높을수록 GC는 더 자주 발생하고 할당률이 너무 높으면 객체는 테뉴어드로 곧장 승격될 것이다. 이 현상을 조기 승격이라고 한다.