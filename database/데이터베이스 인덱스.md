## 데이터베이스 인덱스

### 인덱스

---

![images_guswns3371_post_dcb61735-e5a1-46f3-a206-89898a4ec9e0_image](https://user-images.githubusercontent.com/78543382/218326915-fed17312-f4bb-4dbd-a8f6-c2e68e9adde5.png)

- 인덱스는 데이터베이스에서 테이블의 검색 성능을 높여주는 자료구조이다. 특정 컬럼에 인덱스를 생성하면, 해당 컬럼의 데이터들을 정렬하여 별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장된다. 인덱스를 활용하여 데이터를 조회하면, 위에 그림처럼 검색할 때 인덱스를 타게 되고 먼저 인덱스에 저장되어 있는 데이터의 물리적 주소로 가서 데이터를 가져오는 식으로 동작을 하여 검색 속도의 향상을 가져올 수 있다.
- 인덱스를 활용하면 데이터를 조회하는 SELECT 외에도 UPDATE, DELETE의 성능이 함께 향상된다.
- 만약 인덱스를 사용하지 않는 Column을 조회할 경우, 전체를 탐색해야 한다.
- 인덱스를 구현하기 위한 대표적인 자료구조는 해시 테이블, B+Tree가 있다.
</br>

### 인덱스 사용 장점 (테이블 조회 속도 향상)

---
<details>
<summary>
조건 검색 WHERE절의 효율성
</summary>
    테이블을 만들고 안에 데이터가 쌓이게 되면 테이블의 레코드는 내부적으로 순서가 없이 뒤죽박죽으로 저장이 된다. 이렇게 되면 WHERE 절에 특정 조건에 맞는 데이터들을 찾아낼 때 풀 스캔을 해야한다. 그러나 인덱스를 사용하면 데이터들이 정렬되어 저장되기 때문에 해당 조건에 맞는 데이터들을 훨씬 빠르게 찾아낼 수 있다. 
</details>  
<details>
<summary>
정렬 ORDER BY 절의 효율성
</summary>
    인덱스를 사용하면 ORDER BY에 의한 정렬 과정을 피할 수 있다. ORDER BY는 굉장히 부하가 많이 걸리는 작업이다. 정렬과 동시에 1차적으로 메모리에서 정렬이 이루어지고 메모리보다 큰 작업이 필요하다면 디스크 I/O 도 추가적으로 발생되기 때문이다. 그러나 인덱스를 사용하면 이미 정렬이 되어있고 데이터를 가져오기만 하면 되기 때문에 전반적인 자원의 소모를 하지 않아도 된다.
    
    - 디스크 I/O : 데이터를 작성하고 변경할 적에 디스크에 저장되는 것
</details>  
<details>
<summary>
MIN, MAX의 효율적인 처리가 가능
 </summary>   
    MIN값과 MAX 값을 레코드의 시작 값과 끝 값 한 건씩만 가져오면 되기 때문에 풀 스캔 과정이 필요가 없다. 
</details>      
</br>

### 인덱스 사용 단점 (정렬된 상태 유지를 위한 추가적 작업 필요)

---
<details>
<summary>
DML에 취약
</summary>
    INSERT, UPDATE, DELETE를 통해 데이터가 추가되거나 값이 바뀐다면 인덱스 테이블 내에 있는 값들을 다시 정렬 해야 한다. 또한 인덱스 테이블, 원본 테이블 두 곳 모두 데이터 수정 작업을 해줘야 하는 단점도 발생한다. 따라서 DML이 빈번한 테이블 보다 검색을 위주로 하는 테이블에 인덱스를 생성하는 것이 좋다. 
</details>
<details>
<summary>
정렬된 상태 유지를 위한 추가적 작업 필요
</summary>
- INSERT 연산을 수행하면 새로운 데이터에 대한 인덱스를 추가 하는 연산이 필요하다. </br>
- DELETE 연산을 수행하면 삭제하는 데이터의 인덱스를 사용하지 않는 처리가 필요하다.</br>
- UPDATE 연산을 수행하면 기존 인덱스를 사용하지 않게 처리하고, 갱신된 데이터에 대한 인덱스를 추가하는 처리가 필요하다.</br>
</details>
<details>
<summary>
전체 테이블의 10~15% 이하의 데이터를 처리하는 경우에만 효율적
</summary>
    
    인덱스를 관리하기 위해 데이터베이스의 약 10% 정도의 추가 저장공간이 필요하다.
</details>  
<details>
<summary> 
인덱스를 잘못 관리하면 오히려 성능이 저하된다
</summary>
    - CREATE, DELETE, UPDATE가 빈번한 속성에 인덱스를 걸게 되면 인덱스의 크기가 비대해져 성능이 오히려 저하된다. </br>
    - 인덱스가 적용된 Column에 DELETE, UPDATE 연산을 하면 기존의 인덱스를 삭제 하지 않고 사용하지 않음 처리를 해주기 때문에 인덱스 크기가 비대해진다. </br>
</details>  
</br> 

### 인덱스의 생성 전략

---

- 고유한 값을 많이 가지는 Column(PK)을 인덱스로 사용한다.
- WHERE절에 자주 사용되는Column을 인덱스로 사용한다
- INSERT, DELETE, UPDATE 가 자주 발생하지 않은 Column을 인덱스로 사용한다
- JOIN, WHERE, ORDER BY 에 자주 사용되는 Column을 인덱스로 사용한다
- 데이터 중복도가 낮은 Column을 인덱스로 사용한다

### 참고자료

[https://choicode.tistory.com/27](https://choicode.tistory.com/27) 

[https://velog.io/@guswns3371/데이터베이스-데이터베이스에서-인덱스를-사용하는-이유](https://velog.io/@guswns3371/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%97%90%EC%84%9C-%EC%9D%B8%EB%8D%B1%EC%8A%A4%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0)