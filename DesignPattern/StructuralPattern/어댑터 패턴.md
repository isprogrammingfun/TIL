## 어댑터 패턴

### 어댑터 패턴이란?

 댑터 패턴은 호환되지 않는 인터페이스를 가진 객체들이 협업할 수 있도록 하는 구조적 디자인 패턴이다. 

이 패턴은 이미 구축되어 있는 것을 새로운 어떤것에 사용할 때 양쪽 간의 호환성을 유지해 주기 위해 사용하는 것으로, 기존 시스템에서 새로운 업체에서 제공하는 기능을 사용하려고 할 때 서로 간의 인터페이스를 어댑터로 일치시켜줌으로써 호환성 및 신규 기능 확장을 할 수 있다. 

또한 이 패턴은 클라이언트가 사용하는 인터페이스를 따르지 않는 레거시 코드를 재사용할 수 있게 해준다. 

어댑터 패턴에서 어댑터는 한 객체의 인터페이스를 다른 객체가 이해할 수 있도록 변환하는 특별한 객체이다.

어댑터는 변환의 복잡성을 숨기 위하여 객체 중 하나는 래핑한다. 래핑된 객체는 어댑터를 인식하지 못한다. 어댑터는 데이터를 다양한 형식으로 변환할 수 있을 뿐만 아니라 다른 인터페이스를 가진 객체들이 협업하는 데에도 도움을 줄 수 있으며, 다음과 같이 작동한다.

1. 어댑터는 기존에 있던 객체 중 하나와 호환되는 인터페이스를 받는다.
2. 이 인터페이스를 사용하면 기존 객체는 어댑터의 메서드들을 안전하게 호출할 수 있다.
3. 호출을 수신하면 어댑터는 이 요청을 두 번째 객체에 해당 객체가 예상하는 형식과 순서대로 전달한다.

### 어댑터 패턴의 구조

어댑터 패턴에는 기존 시스템의 클래스를 상속해서 호환 작업을 해주는 경우와, 합성(기존 클래스를 상속을 통한 확장하는 대신에, **필드로 클래스의 인스턴스를 참조**하게 만드는 설계)해서 호환 작업을 해주는 경우 총 두 가지 패턴 방법으로 나뉘게 된다.

- 객체 어댑터 (Object Adaptor)

합성된 멤버에게 위임을 이용한 어댑터 패턴

자기가 해야 할 일을 클래스 멤버 객체의 메소드에게 다시 시킴으로써 목적을 달성하는 것을 위임이라고 한다.

합성을 활용했기 때문에 런타임 중에 Adaptee(Service)가 결정되어 유연하다.

그러나 Adaptee(Service) 객체를 필드 변수로 저장해야 되기 때문에 공간 차지 비용이 든다. 

![structure-object-adapter-indexed](https://github.com/isprogrammingfun/TIL/assets/78543382/650dba92-19f8-4dd2-8fef-c7570427d5e8)

1. Client : 기존 시스템을 어댑터를 통해 이용하려는 쪽. 즉, 프로그램의 기존 비즈니스 로직을 포함하는 클래스이다.  Client Interface를 통하여 Service를 이용할 수 있게 된다.
2. Target (Client Interface) : 어댑터가 구현하는 인터페이스이고, 다른 클래스들이 클라이언트 코드와 공동 작업할 수 있도록 따라야 하는 프로토콜이다. 
3. Adaptee(Service) : 어댑터 대상 객체. 기존 시스템 / 외부 시스템 / 써드파티 라이브러리이다.  
4. Adapter : Client와 Adaptee(Service) 중간에서 호환성이 없는 둘을 연결시킨다. 서비스 객체를 래핑하는 동안 클라이언트 인터페이스를 구현한다. 어댑터는 어댑터 인터페이스를 통해 클라이언트로부터 호출들을 수신한 후 이 호출을 래핑된 서비스 객체가 이해할 수 있는 형식의 호출들로 변환한다.
- 클래스 어댑터 (Class Adaptor)

클래스 상속을 이용한 어댑터 패턴

Adaptee(Service)를 상속했기 때문에 따로 객체 구현없이 바로 코드 재사용이 가능하다.

상속은 대표적으로 기존에 구현된 코드를 재사용하는 방식이지만, 자바에서는 다중 상속 불가 문제 때문에 권장하지 않는 방법이다. 

![structure-class-adapter-indexed](https://github.com/isprogrammingfun/TIL/assets/78543382/e462fb1e-30fc-4520-be7e-ea4d563c49bf)

**클래스 어댑터**는 객체를 래핑할 필요가 없다. 그 이유는 클라이언트와 서비스 양쪽에서 행동들을 상속받기 때문이다. 위의 어댑테이션(적용)은 오버라이딩된 메서드 내에서 발생한다. 위 어댑터는 기존 클라이언트 클래스 대신 사용할 수 있다.

### 언제 사용하는가?

1.  기존 클래스를 사용하고 싶지만 새로운 인터페이스가 나머지 코드와 호환되지 않을 때
2. 이미 만든 것을 재사용하고자 하나 이 재사용 가능한 라이브러리를 수정할 수 없을 때
3. 이미 만들어진 클래스를 새로운 인터페이스(API)에 맞게 개조할때
4. 소프트웨어의 구 버전과 신 버전을 공존시키고 싶을때

### 패턴 장점

1. 프로그램의 기본 비즈니스 로직에서 인터페이스 또는 데이터 변환 코드를 분리할 수 있기 때문에 단일 책임 원칙(SRP)을 만족한다.
2. 기존 클래스 코드를 건들지 않고 클라이언트 인터페이스를 통해 어댑터와 작동하기 때문에 개방 폐쇄 원칙(OCP)을 만족한다.
3. 만일 추가로 필요한 메소드가 있다면 어댑터에 빠르게 만들 수 있다. 만약 버그가 발생해도 기존의 클래스에는 버그가 없으므로 Adapter 역할의 클래스를 중점적으로 조사하면 되고, 프로그램 검사도 쉬워진다.

### 패턴 단점

1. 새로운 인터페이스와 어댑터 클래스들을 도입해야 하기 때문에 코드의 복잡성이 증가한다.
2. 때로는 직접 서비스(Adaptee) 클래스를 변경하는것이 간단할수 있는 경우가 있기 때문에 신중히 선택하여야 한다.

### 참고 자료

https://refactoring.guru/ko/design-patterns/adapter

[https://inpa.tistory.com/entry/GOF-💠-어댑터Adaptor-패턴-제대로-배워보자](https://inpa.tistory.com/entry/GOF-%F0%9F%92%A0-%EC%96%B4%EB%8C%91%ED%84%B0Adaptor-%ED%8C%A8%ED%84%B4-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EB%B0%B0%EC%9B%8C%EB%B3%B4%EC%9E%90)