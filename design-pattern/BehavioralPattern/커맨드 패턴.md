## 커맨드 패턴

### 커맨드 패턴이란?

커맨드 패턴은 요청에 대한 모든 정보가 포함된 독립실행형 객체로 변환하는(캡슐화) 행동 디자인 패턴이다. 이 변환은 주어진 메서드나 함수에 다양한 요청들을 매개 변수로 전달하게 할 수 있고, 요청의 실행을 지연 또는 대기열에 넣을 수 있도록 하고, 또 실행 취소할 수 있는 작업을 지원할 수 있도록 한다. 이런 캡슐화 덕에 클라이언트는 단순 명령만 내리면 원하는 결과를 얻을 수 있다. 

예시로 새로운 텍스트 편집기 앱에서 다양한 작업을 위한 여러 버튼이 있는 도구 모음을 만들기 위해 도구 모음의 버튼들과 일반 버튼들에 사용할 수 있는 Button 클래스를 만들었다고 하자. 

![problem1](https://github.com/isprogrammingfun/TIL/assets/78543382/ef6cf10c-2042-44f6-b1d0-ae6bfcea900a)

해당 버튼들은 모두 비슷해 보이지만 각각 다른 기능들을 수행해야 한다. 그렇다면 이 버튼들의 다양한 클릭 핸들러들에 대한 코드는 어디에 둬야 할까? 가장 간단한 해결책은 버튼이 사용되는 각 위치에 대한 자식 클래스들을 만드는 것이다. 이런 자식 클래스들에는 버튼 클릭 시 실행되어야 하는 코드가 포함될 것이다.

![problem2](https://github.com/isprogrammingfun/TIL/assets/78543382/b63ccfed-bf11-468c-9372-bf05c0804b45)

![problem3-ko](https://github.com/isprogrammingfun/TIL/assets/78543382/53af7026-d418-4601-85cc-aa4dded81c9f)

그러나 이런 방식으로 구현을 하면 심각한 문제가 발생한다. 수많은 자식 클래스들이 생길 것이고, 기초 Button 클래스를 수정할 때 마다 관련 자식 클래스의 코드를 깨뜨릴 위험이 생긴다. 또한 여러 자식 클래스에 공통된 코드를 반복해서 작성해야 할 수 있다. 

이를 해결하기 위해 다음과 같이 할 수 있다.

![solution1-ko](https://github.com/isprogrammingfun/TIL/assets/78543382/c3c5f56b-b2f5-4a44-9fcc-298a076288a0)

사용자 인터페이스 객체가 비즈니스 로직 객체의 메서드를 호출하고 일부 인수를 전달한다. 이 프로세스는 일반적으로 한 객체가 다른 객체에 요청을 보내는 것으로 불린다. 그러나 이렇게 되면 사용자 인터페이스와 비즈니스 로직 간의 의존성이 생겨 유지보수 및 확장성이 어려울 수 있다. 이를 해결하기 위해 커맨드 패턴을 사용하면 좋다. 

![solution2-ko](https://github.com/isprogrammingfun/TIL/assets/78543382/2a0acbf1-8f0d-4217-8f81-e72ae0d493c0)

![solution3-ko](https://github.com/isprogrammingfun/TIL/assets/78543382/5fbae46c-ae77-449e-af17-a8ade3954965)

커맨드 패턴은 사용자 인터페이스 객체들이 요청을 직접 보내서는 안된다고 한다. 대신 요청을 작동시키는 단일 메서드를 가진 별도의 커맨드 클래스로 추출하라고 제안한다. 

커맨드 객체들은 다양한 사용자 인터페이스 객체들과 비즈니스 로직 객체들 간의 링크 역할을 해준다. 이렇게 되면 사용자 인터페이스 객체는 어떤 비즈니스 로직 객체가 요청을 받을지, 이 요청을 어떻게 처리하는지에 대해 알 필요가 없다. 사용자 인터페이스 객체는 커맨드를 작동시킬 뿐이며, 작동된 커맨드는 모든 세부 사항을 처리한다.

### 커맨드 패턴의 구조

![structure-indexed](https://github.com/isprogrammingfun/TIL/assets/78543382/09a21fb8-bfc0-43b9-a367-c1cf67317c96)

1. Invoker : 요청들을 시작하는 역할을 한다. Invoker는 요청을 Receiver에게 직접 보내는 대신 해당 커맨드를 작동시킨다. Invoker는 커맨드 객체를 생성할 책임이 없으며 일반적으로 생성자를 통해 클라이언트로부터 미리 생성된 커맨드를 받는다. 
2. Command : 커맨드를 실행하기 위한 인터페이스를 정의한다. 실행될 기능을 execute 메서드로 선언한다.  
3. Concrete Command : 커맨드 인터페이스를 구현해 실제 동작들을 수행한다. 자체적으로 작업을 수행해서는 안 되며  비즈니스 로직 객체 중 하나에 호출을 전달해야 한다. 
4. Receiver : 실제 작업을 수행한다. ConcreteCommand의 기능을 실행하기 위해 사용하는 클래스이다. 
5. Client : Concrete Command를 만들고 설정한다. 클라이언트는 Receiver 인스턴스를 포함한 모든 요청 매개변수들을 커맨드의 생성자로 전달해야 하며 그렇게 만들어진 커맨드는 하나 또는 여러 Invoker와 연관될 수 있다. Client는 Invoker를 통해 Receiver에게 할 행동을 결정한다. 

### 언제 사용하는가?

1. 객체를 매개변수화 하려는 경우 
2. 작업들의 실행을 예약하거나, 대기열에 넣거나 원격으로 실행하려는 경우
3. 되돌릴 수 있는 작업을 구현하려고 하는 경우 

### 패턴 장점

1. 단일 책임의 원칙을 준수한다. 작업을 호출하는 클래스와 작업을 수행하는 클래스를 분리할 수 있다. 
2. 개방/폐쇄 원칙을 준수한다. 기존 클라이언트 코드를 손상하지 않고 새 커맨드들을 도입할 수 있다. 

### 패턴 단점

1. Invoker와 Receiver 사이에 완전히 새로운 레이어를 도입하기 때문에 코드가 더 복잡해질 수 있다. 

### 참고 자료

https://huisam.tistory.com/entry/CommandPattern

https://refactoring.guru/ko/design-patterns/command