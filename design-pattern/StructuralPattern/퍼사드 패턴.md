## 퍼사드 패턴

### 퍼사드 패턴이란?

 퍼사드 패턴은 호환되지 사용하기 복잡한 클래스 라이브러리에 대해 사용하기 편하게 간편한 인터페이스를 제하는 구조적 디자인 패턴이다. 예를 들어 라이브러리의 각 클래스와 메서드들이 어떤 목적의 동작인지 이해하기 어려워 바로 가져다 쓰기에는 난이도가 높을 때, 이에 대한 적절한 네이밍과 정리를 통해 사용자로 하여금 쉽게 라이브러리를 다룰 수 있도록 인터페이스를 만드는데, 우리가 교재를 보고 필기노트에 재정리를 하듯 클래스를 재정의 하는 행위라고 보면 된다. 

만약 정교한 라이브러리나 프레임워크에 속하는 광범위한 객체들의 집합으로 우리의 코드를 작동하게 해야 한다고 생각해보자. 일반적으로 우리는 이러한 객체들을 모두 초기화하고, 종속성 관계들을 추적하고, 올바른 순서로 메서드들을 실행하는 등의 작업을 수행해야 한다. 이런 과정에서, 우리의 클래스들의 비즈니스 로직이 타사 클래스들의 구현 세부 사항들과 밀접하게 결합하여 코드를 이해하고 유지 관리하기가 어렵다. 퍼사드 패턴은 이를 해결할 수 있다. 퍼사드는 복잡한 하위 시스템에 대한 간단한 인터페이스를 제공하는 클래스이다. 하위 시스템과 직접 작업하는 것과 비교하면 퍼사드는 필요한 기능들만 가진 제한된 기능성을 제공한다. 

![live-example-ko](https://github.com/isprogrammingfun/TIL/assets/78543382/c8811eaa-9cf5-4d44-812b-97971e4776e9)

이 사진에서 교환원이 퍼사드의 역할을 하고 있다. 교환원이 다양한 서비스에 대한 인터페이스를 제공한다. 이처럼 퍼사드(Facade) 패턴은 복잡하게 얽혀 있는 것을 정리해서 사용하기 편한 인터페이스를 고객에게 제공한다고 보면 된다. 그래서 고객은 복잡한 시스템을 알 필요 없이 시스템의 외부에 대해서 단순한 인터페이스를 이용하기만 하면 된다. 퍼사드를 이용하면 자칫 동작의 목적과 같은 중요한 사항을 놓치는 실수를 줄일 수 있다.

### 퍼사드 패턴의 구조

![structure-indexed](https://github.com/isprogrammingfun/TIL/assets/78543382/9d31cb2b-bc11-45c0-bb75-24dde1fcf0c6)

1. Facade : 서브시스템 기능을 편리하게 사용할 수 있도록 하기 위해 여러 시스템과 상호 작용하는 복잡한 로직을 재정리해서 높은 레벨의 인터페이스를 구성한다. Facade 역할은 서브 시스템의 많은 역할에 대해 ‘단순한 창구’가 된다. 클라이언트와 서브시스템이 서로 긴밀하게 연결되지 않도록 한다.
2. Additional Facade : 클래스를 생성하여 하나의 퍼사드를 관련 없는 기능들로 오염시켜 복잡한 구조로 만드는 것을 방지할 수 있다. 추가 퍼사드들은 클라이언트들과 다른 퍼사드들 모두에 사용할 수 있다.
3. SubSystem : 수십 개의 다양한 객체들로 구성된다. 이 모든 객체가 의미 있는 작업을 수행하도록 하려면, 하위 시스템의 세부적인 구현 정보를 깊이 있게 살펴야 한다. 예를 들어 올바른 순서로 객체들을 초기화하고 그들에게 적절한 형식의 데이터를 제공하는 등의 작업을 수행해야 한다.
4. Client : 서브 시스템에 직접 접근하는 대신 Facade를 사용한다.
- 퍼사드 패턴은 전략 패턴이나 팩토리 패턴과 같은 여타 다른 디자인 패턴과는 다르게 **클래스 구조가 정형화 되지 않은 패턴**이다. 반드시 클래스 위치는 어떻고 어떤 형식으로 위임을 해야되고 이런 규칙이 없다. 그냥 퍼사드 클래스를 만들어 적절히 기능 집약화만 해주면 그게 디자인 패턴이 되는 것이다. 그렇기에 퍼사드 패턴은 패턴이라기 보단 논리에 가깝다.

### 언제 사용하는가?

1. 복잡한 하위 시스템에 대한 제한적이지만 간단한 인터페이스가 필요할 때
2. 하위 시스템을 계층들로 구성하려고 할 때 
3. 시스템을 사용하고 있는 외부와 결합도가 너무 높아 의존성 낮추려고 할 때

### 패턴 장점

1. 하위 시스템의 복잡성에서 코드를 분리하여, 외부에서 시스템을 사용하기 쉬워진다.
2. 하위 시스템 간의 의존 관계가 많을 경우 이를 감소시키고 의존성을 한 곳으로 모을 수 있다.
3. 복잡한 코드를 감춤으로써, 클라이언트가 시스템의 코드를 모르더라도 Facade 클래스만 이해하고 사용 가능하다.

### 패턴 단점

1. 퍼사드가 앱의 모든 클래스에 결합된 God 객체가 될 수 있다.
2. 퍼사드 클래스 자체가 서브시스템에 대한 의존성을 가지게 되어 의존성을 완전히는 피할 수는 없다.
3. 결국엔 추가적인 코드가 늘어나는 것이기 때문에 유지보수 측면에서 공수가 더 많이 들게 된다. 따라서 추상화 하고자 하는 시스템이 얼마나 복잡한지 퍼사드 패턴을 통해서 얻게 되는 이점과 추가적인 유지보수 비용을 비교해보며 결정하여야 한다.

### 참고 자료

https://refactoring.guru/ko/design-patterns/facade

[https://inpa.tistory.com/entry/GOF-💠-퍼사드Facade-패턴-제대로-배워보자](https://inpa.tistory.com/entry/GOF-%F0%9F%92%A0-%ED%8D%BC%EC%82%AC%EB%93%9CFacade-%ED%8C%A8%ED%84%B4-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EB%B0%B0%EC%9B%8C%EB%B3%B4%EC%9E%90)