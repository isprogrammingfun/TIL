## Nginx - Nginx는 왜 등장했는가?

### Nginx란?

Nginx는 웹 서버 소프트웨어로, 가벼움과 높은 성능을 목표로 한다. 웹 서버, 리버스 프록시 및 메일 프록시 기능을 가진다. Nginx는 요청에 응답하기 위해 비동기 이벤트 기반 구조를 가진다. 이것은 아파치 HTTP 서버의 스레드.프로세스 기반 구조를 가지는 것과는 대조적이다. 이러한 구조는 서버에 많은 부하가 생길 경우의 성능을 예측하기 쉽게 해준다. 

> 리버스 프록시 (reverse proxy) : 컴퓨터 네트워크에서 클라이언트를 대신해서 한 대 이상의 서버로부터 자원을 추출하는 프록시 서버의 일종이다. 그리고 추출한 자원들을 클라이언트로 보낸다. 관련 클라이언트들을 위해 임의의 서버에 접석하는 중간 매개체인 포워드 프록시와는 반대로, 리버스 프록시는 관련 서버들을 위해 임의의 클라이언트가 해당 서버에 접속하는 중간 매개체이다.
프록시 : 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템이나 응용 프로그램을 가리킨다. 프록시 서버 중 일부는 프록시 서버에 요청된 내용들을 캐시를 이용해 저장해 둔다. 이렇게 캐시를 해 두고 난 후에, 캐시 안에 있는 정보를 요구하는 요청에 대해서는 원격 서버에 접속하여 데이터를 가져올 필요가 없게 됨으로써 전송 시간을 절약할 수 있게 됨과 동시에 불필요하게 외부와의 연결을 하지 않아도 된다는 장점을 갖게 된다. 또한 외부와의 트래픽을 줄이게 됨으로써 네트워크 병목 현상을 방지하는 효과도 얻을 수 있게 된다.
> 
> 
> ![img1](https://github.com/isprogrammingfun/TIL/assets/78543382/5bd75070-e40b-4bce-8856-bc9cdf4b258f)
> 

### 초기 웹 상황

웹 브라우저에 정보를 표현할 수 있게 해주는 마크업 언어 HTML이 제일 먼저 개발되었다. 이 언어는 기존에 작성된 화면을 보여주기 때문에 초기 웹 사이트들은 모두 정적(static)인 웹사이트였다. 따라서 단순히 브라우저에 정보를 표현해주는게 전부라 서버가 데이터를 처리할 부담이 없었다. 하지만 이후 스크립트 등장으로 동적인 데이터를 다루고, SPA(Single Page Application)라는 개념이 등장하면서 서버에서 처리해야 할 양이 방대해졌다. SPA는 기존의 웹페이지와는 달리 기본적인 정적인 정보는 한번에 다운받아 이후 페이지 갱신 시 필요한 데이터만을 전달받아 갱신하는 방식으로 개발되었다. 

이때, 사용자마다 필요한 데이터들이 다를 수 밖에 없었고, 이로써 이전보다 복잡한 로직이 필요해졌다. 하지만 정적인 페이지와 동적인 데이터 모두 한 서버에서 담당하게 되어 서버는 부담이 커지고, 수행 속도도 느려짐에 따라 사이트가 느려지게 되었다. 그래서 이에 대한 해결책으로 정적인 페이지는 정적인 페이지대로, 동적인 페이지는 동적인 페이지대로, 각각 다른 서버에서 처리를 하면 어떨까? 라는 생각이 나왔고, 그리하여 정적인 페이지는 ws (web server) 동적인 페이지는 was (web application server)로 분리해 처리하게 되었다. 즉, ws는 클라이언트의 요청을 처리하는 기능을 담당하고, was는 db 조회나 다양한 로직을 처리하는 기능을 담당하는 서버로 분리되었다. 그래서 Unix 기반으로 만들어진 최초의 서버 NCSA HTTPd를 사용했다. 

### Apache 서버의 등장

최초의 웹서버 NSCA HTTPd에서 발생하는 버그에 대한 불편함으로, 대안으로 등장한 것이 Apache 서버이다. 1995년 당시에는 유닉스 기반으로 만들어진 최초의 웹서버(WS)인 NSCA와 HTTPd가 있었다. 그런데 이 프로그램은 버그가 굉장히 많아 개발자들이 사용할 때 불편함이 있었다. 그래서 버그를 수정하며 구조를 변경하고, 기능을 추가해서 만든 것이 아파치 서버이다. 그럼 아파치 서버의 구조는 어떻게 되어있을까?

### Apache 서버의 구조

아파치 서버는 요청이 들어오면 커넥션(Connection)을 생성하기 위해 프로세스를 생성한다. 그래서 새로운 클라이언트의 요청이 들어올 때마다 새로운 프로세스를 만든다. 이는 유닉스 계열의 OS가 네트워크 커넥션을 형성하는 모델을 그대로 적용한 것이다. 

그런데 프로세스를 만드는 것은 작업이 매우 오래걸리므로, 요청이 들어오기 전에 프로세스를 미리 만들어주는 Prefork 방식을 사용했다.

![img2](https://github.com/isprogrammingfun/TIL/assets/78543382/b211c740-e98d-443a-8c8a-416cd6fe4c2b)

> Prefork : 새로운 클라이언트로부터 요청이 들어오면 미리 만들어놓은 프로세스를 사용하는 방식. 만일 만들어놓은 모든 프로세스가 할당된다면, 추가로 프로세스를 만든다.
> 

이러한 구조는 개발하기 쉬워서 개발자들은 다양한 모듈을 만들고 아파치 서버에 빠르게 기능을 추가할 수 있다. 이렇게 아파치 서버는 동적 컨텐츠를 쉽게 처리할 수 있게 되고, 확장성 또한 뛰어나다. 요청을 받고 응답을 처리하는 과정을 하나의 서버에서 해결하기 좋다.

### C10K 처리에 대한 한계

이렇게 문제없이 사용하던 중, 아파치 서버는 C10K라는 문제를 마주하게 된다. 1999년 이 시기에는 인터넷 트래픽이 계속 증가하는 상황이었다. 점점 컴퓨터 보급량이 많아지고 요청이 많아짐에 따라, 서버가 많은 양의 커넥션을 수용하지 못하는 것이었다. 이전에는 서버가 처리할 요청양이 그 당시 기술로 감당할 수 있었는데, 이때부터 아파치 서버의 한계가 드러난다.

**C10K**

C10K란 Connection 10000 Problem의 약자로, 커넥션 1만개에 대해 발생한 문제를 뜻한다. 서버에 동시에 연결된 커넥션이 많아졌을때 더 이상 커넥션을 만들지 못하는 문제가 발생한 것이다. 게다가 한 클라이언트는 하나의 커넥션을 통해 여러개의 요청을 보낼수도 있다. 또 커넥션 하나를 생성하는데는 여러 절차가 따르기 때문에 오랜 시간이 걸린다. 이러한 동시간대에 연결된 커넥션의 개수는 정말 많았고, 서버는 커넥션 수가 1만 단위가 넘어가는 순간 더 이상 커넥션을 생성하지 못하는 상황에 놓이게 된 것이다. 

### 왜 Apache 서버는 C10K를 해결하지 못했을까?

프로세스가 너무 많이 생성되어, 메모리 부족현상으로 이어졌기 때문이다.

C10K의 문제는 하드웨어 쪽에선 문제될 부분이 없었다. 하드웨어의 성능은 그 당시의 컨텐츠 용량을 담는데 충분했기 때문이다. 

C10K를 해결하지 못했던 원인은 아파치 서버의 구조에 있었다. 아파치 서버의 구조는 커넥션이 생성될 때마다 한 프로세스가 할당되기 때문에, 동시에 처리하고 있는 커넥션이 많아지면 그만큼 생성되는 프로세스가 많아진다. 결국 프로세스가 많아져서 메모리 부족현상으로 이어지게 된 것이다.

### Apache 서버의 한계점 정리

위에 내용들을 기반으로 Apache 서버의 한계점을 정리해보면 다음과 같다.

1. 메모리 부족 : 프로세스가 너무 많이 생성된다. 커넥션이 1만개이면 프로세스도 1만개 생성된다.
2. 무겁다 : 감당해야할 프로세스가 많아질 수 있고, 다양한 모듈을 설치하다보면 서버가 정말 무거워진다.
3. CPU가 부하된다 : CPU 코어 하나당 동시적으로 처리해야 할 프로세스의 양이 많아서 부하된다.

### 2004년 : Nginx의 등장

2004년, 아파치 서버의 구조를 보완하기 위한 소프트웨어가 나온다. 그게 바로 Nginx이다. 초창기의 Nginx는 아파치와 함께 사용하기 위해 만들어졌다. 웹서버이긴 하지만, 아파치 서버를 완전히 대체하기 위한 목적이 아니었다. 아파치 서버가 지닌 구조적 한계를 Nginx를 사용함으로써 극복하려고 했다.

### Nginx와 Apache 서버와의 협력관계

그렇다면 아파치 서버의 한계를 어떻게 Nginx로 극복할 수 있을까? 간단히 말하면, 아파치 서버에 Nginx를 올려두면 된다. 이렇게 하면 기존의 아파치 서버가 감당해야했던 수많은 동시 커넥션을 Nginx가 대신해서 유지해준다. 동시 커넥션을 유지 못하는 아파치 서버의 부하 문제점을 Nginx로 크게 줄일 수 있게 된 것이다. Nginx는 정적파일에 대한 요청을 본인이 모두 처리하고, 동적인 파일을 요청받았을때만 뒤에 있는 아파치 서버와 커넥션을 형성한다. 

### 참고자료

https://ko.wikipedia.org/wiki/Nginx

[https://velog.io/@msung99/Nginx-1995년-역사부터-뜯어보는-Nginx-등장배경부터-내부-메커니즘까지](https://velog.io/@msung99/Nginx-1995%EB%85%84-%EC%97%AD%EC%82%AC%EB%B6%80%ED%84%B0-%EB%9C%AF%EC%96%B4%EB%B3%B4%EB%8A%94-Nginx-%EB%93%B1%EC%9E%A5%EB%B0%B0%EA%B2%BD%EB%B6%80%ED%84%B0-%EB%82%B4%EB%B6%80-%EB%A9%94%EC%BB%A4%EB%8B%88%EC%A6%98%EA%B9%8C%EC%A7%80)

[https://velog.io/@devjooj/Server-Ngnix-왜-사용할까](https://velog.io/@devjooj/Server-Ngnix-%EC%99%9C-%EC%82%AC%EC%9A%A9%ED%95%A0%EA%B9%8C)